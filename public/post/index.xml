<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on chooblarin&#39;s blog</title>
    <link>http://chooblarin.github.io/post/index.xml</link>
    <description>Recent content in Posts on chooblarin&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 chooblarin</copyright>
    <lastBuildDate>Mon, 17 Jul 2017 14:08:00 +0900</lastBuildDate>
    <atom:link href="http://chooblarin.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>p5.jsとBeat Detection</title>
      <link>http://chooblarin.github.io/post/trying-beat-detection/</link>
      <pubDate>Mon, 17 Jul 2017 14:08:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/trying-beat-detection/</guid>
      <description>

&lt;p&gt;実は，兼ねてからJavaScriptで絵を描く遊びが好きで，ふと思いたつと書いては&lt;a href=&#34;https://chooblarin.tumblr.com&#34;&gt;Tumblr&lt;/a&gt;に投稿している．この中の多くは&lt;a href=&#34;https://p5js.org&#34;&gt;p5.js&lt;/a&gt;を使って書いた．&lt;/p&gt;

&lt;h2 id=&#34;音に合わせてなにかを動かしたい&#34;&gt;音に合わせてなにかを動かしたい&lt;/h2&gt;

&lt;p&gt;p5.jsには&lt;a href=&#34;https://p5js.org/reference/#/libraries/p5.sound&#34;&gt;p5.sound library&lt;/a&gt;という拡張がある．Web Audio APIに関する知識はほとんど無いけどこれならすぐに試せそう．これを使って絵を動かしてみたくなった．&lt;/p&gt;

&lt;p&gt;オーディオの可視化に関しては以下の記事が大変参考になった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.airtightinteractive.com/2013/10/making-audio-reactive-visuals/&#34;&gt;Making Audio Reactive Visuals — Airtight Interactive&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般的に，以下の4つの要素が重要とのこと．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Volume&lt;/li&gt;
&lt;li&gt;Waveform&lt;/li&gt;
&lt;li&gt;Level&lt;/li&gt;
&lt;li&gt;Beat Detection&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;音に合わせて動かしたいので，上の記事のBeat Detectionアルゴリズムをそのまま拝借．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Volumeの値を監視する．&lt;/li&gt;
&lt;li&gt;Volumeの値が閾値を超えたときにBeatと判定し，閾値をVolumeの値で更新．&lt;/li&gt;
&lt;li&gt;閾値は一定の割合(Decay Rate)で小さくなる．&lt;/li&gt;
&lt;li&gt;Beatの発生直後の一定時間(Hold Time)は閾値が減少しない．&lt;/li&gt;
&lt;/ol&gt;

&lt;script src=&#34;https://gist.github.com/chooblarin/5597a1db253a77adf6758fe86d67f87f.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;

&lt;p&gt;p5.jsを使ったサンプルは下記．5つの周波数レンジ毎にVolumeの値を取得してBeat Detectionしてみました．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import p5 from &#39;p5&#39;
import &#39;p5/lib/addons/p5.sound&#39;
import BeatDetector from &#39;./BeatDetector&#39;

export function sketch(p) {

  const ranges = [&#39;bass&#39;, &#39;lowMid&#39;, &#39;mid&#39;, &#39;highMid&#39;, &#39;treble&#39;]

  let p5canvas
  let sampleSound
  let amplitude
  let fft

  let detectors = {}

  p.preload = function () {
    sampleSound = p.loadSound(&#39;assets/sample.mp3&#39;)
  }

  p.setup = function () {
    p5canvas = p.createCanvas(p.windowWidth, p.windowHeight)
    p5canvas.mouseClicked(togglePlay)

    amplitude = new p5.Amplitude()
    fft = new p5.FFT()

    sampleSound.play()

    detectors[&#39;bass&#39;] = new BeatDetector(10, 0.85, 0.65)
    detectors[&#39;lowMid&#39;] = new BeatDetector(30, 0.97, 0.40)
    detectors[&#39;mid&#39;] = new BeatDetector(20, 0.90, 0.3)
    detectors[&#39;highMid&#39;] = new BeatDetector(40, 0.97, 0.3)
    detectors[&#39;treble&#39;] = new BeatDetector(20, 0.90, 0.15)
  }

  p.draw = function () {
    p.clear()
    p.background(0)

    fft.analyze()

    for (let i = 0; i &amp;lt; ranges.length; i += 1) {
      const r = ranges[i]
      const x = i * (p.width / ranges.length) + 30
      const e = fft.getEnergy(r)
      const level = e / 255.0

      const beatDetector = detectors[r]
      const isBeatDetected = beatDetector.detect(level)

      p.fill(255, 0, 0)
      drawLevelBar(x, level)

      p.fill(0, 255, 0)
      drawThreshold(x, beatDetector.cutOff)

      if (isBeatDetected) {
        p.fill(255)
        p.ellipse(x, 100, 60, 60)
      }
    }
  }

  let togglePlay = () =&amp;gt; {
    if (sampleSound.isPlaying()) {
      sampleSound.pause()
    } else {
      sampleSound.play()
    }
  }

  let drawThreshold = (x, level) =&amp;gt; {
    const barWidth = 60
    const maxHeight = p.height - 400
    const barHeight = p.map(level, 0, 1.0, 0, maxHeight)
    p.rect(x - 30, p.height - barHeight, barWidth, 10)
  }

  let drawLevelBar = (x, level) =&amp;gt; {
    const barWidth = 60
    const maxHeight = p.height - 400
    const barHeight = p.map(level, 0, 1.0, 0, maxHeight)
    p.rect(x - barWidth / 2, p.height - barHeight, barWidth, barHeight)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上です．引き続きよろしくお願いします．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RxSwiftのSchedulersと戯れる</title>
      <link>http://chooblarin.github.io/post/understanding-schedulers/</link>
      <pubDate>Fri, 05 May 2017 13:36:25 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/understanding-schedulers/</guid>
      <description>

&lt;p&gt;iOSのアプリ開発を始めて1年が経過しました．RxSwiftとの付き合いも1年が経過しました．最近は仕事で再びAndroidの担当になりました．&lt;/p&gt;

&lt;p&gt;この記事はRxSwiftとSchedulersについて書きました．GCDの話は出て来ませんので真剣に勉強した方には以下の解説がとても素晴らしいです．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mixi-inc/iOSTraining/wiki/8.2-Grand-Central-Dispatch&#34;&gt;8.2 Grand Central Dispatch · mixi-inc/iOSTraining Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;observableとスレッド&#34;&gt;Observableとスレッド&lt;/h2&gt;

&lt;p&gt;Swiftは3.1です．&lt;/p&gt;

&lt;p&gt;まず，RxSwiftでてきとうなObservableを作ります．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in
  observer.onNext(&amp;quot;YO!😎&amp;quot;)
  observer.onCompleted()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;observable.subscribe(onNext: { (message: String) in
  print(message)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に，5秒後に「YO!」を受け取るようにObservableを変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in
  Thread.sleep(forTimeInterval: 5) // Blocking
  observer.onNext(&amp;quot;YO!😎&amp;quot;)
  observer.onCompleted()
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observableの処理は，通常は&lt;code&gt;subscribe&lt;/code&gt;を呼び出したスレッドで実行されます．
なので&lt;code&gt;Thread.sleep&lt;/code&gt;はmainスレッドをブロックしています．mainスレッドをブロックするのはイケないことなので，明示的に別のスレッドで処理するように変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5) // ...zzZ

    observer.onNext(&amp;quot;YO!😎&amp;quot;)
    observer.onCompleted()
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「YO!」がどのスレッドから来ているのか知りたいのでヘルパー関数を作って&lt;code&gt;subscribe&lt;/code&gt;する側を少し変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func which() -&amp;gt; String {
  return Thread.isMainThread ? &amp;quot;main&amp;quot; : &amp;quot;background&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;observable.subscribe(onNext: { (message: String) in
  print(&amp;quot;\(message) on \(which())&amp;quot;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 on background
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バックグラウンドから「YO!」が届きました．&lt;/p&gt;

&lt;p&gt;mainスレッド以外からUIに触ろうとするとSystemに怒られてしまいます．なので別スレッドで眠ってから「YO!」の送信だけをmainスレッドで行うように変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5)

    DispatchQueue.main.async {
      observer.onNext(&amp;quot;YO!😎&amp;quot;)
      observer.onCompleted()
    }
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;YO!😎 on main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うまくいきました．これでノンブロッキングYO!YO!が可能になりました．&lt;/p&gt;

&lt;p&gt;さて，ここまでの「YO!」を振り返ってみます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  observer.onNext(&amp;quot;YO!😎&amp;quot;) // where subscribe() is called

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5)
    observer.onNext(&amp;quot;YO!😎&amp;quot;) // background

    DispatchQueue.main.async {
      observer.onNext(&amp;quot;YO!😎&amp;quot;) // main
      observer.onCompleted()
    }
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 on main
YO!😎 on background
YO!😎 on main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いい感じです．&lt;/p&gt;

&lt;h2 id=&#34;schedulers&#34;&gt;Schedulers&lt;/h2&gt;

&lt;p&gt;次はいよいよSchedulerを使います．Observableの&lt;code&gt;observeOn&lt;/code&gt;に&lt;code&gt;MainScheduler&lt;/code&gt;を指定します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;observable
  .observeOn(MainScheduler.instance)
  .subscribe(onNext: { (message: String) in
    print(&amp;quot;\(message) (Here is \(which()))&amp;quot;)
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 (Here is main)
YO!😎 (Here is main)
YO!😎 (Here is main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;subscribe&lt;/code&gt;の中が全てmainスレッドで実行されるようになりました．&lt;code&gt;MainScheduler&lt;/code&gt;を指定したおかげで&lt;code&gt;DispatchQueue.main.async&lt;/code&gt;は不要になりました．&lt;/p&gt;

&lt;p&gt;「YO!」がどこから来ているのかわからなくなってしまったので少し変更を加えます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  observer.onNext(&amp;quot;YO!😎 from \(which()).&amp;quot;)

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5)

    observer.onNext(&amp;quot;YO!😎 from \(which()).&amp;quot;)
    observer.onCompleted()
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 from main. (Here is main)
YO!😎 from background. (Here is main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;observeOn&lt;/code&gt;の振る舞いがわかりました．&lt;/p&gt;

&lt;p&gt;次に，&lt;code&gt;subscribeOn&lt;/code&gt;でObservableの処理を実行するスレッドを指定します．先ほど述べた通り，Observableの処理は，通常は&lt;code&gt;subscribe&lt;/code&gt;を呼び出したスレッドで実行されます．
しかし&lt;code&gt;subscribeOn&lt;/code&gt;を使うとこれを変更することができます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;observable
  .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .default))
  .observeOn(MainScheduler.instance)
  .subscribe(onNext: { (message: String) in
    print(&amp;quot;\(message) (Here is \(which()))&amp;quot;)
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 from background. (Here is main)
YO!😎 from background. (Here is main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スリープの処理をDispatchQueueで指定する必要が無くなりますので，Observableはこうなります．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in
  Thread.sleep(forTimeInterval: 5)
  observer.onNext(&amp;quot;YO!😎 from \(which()).&amp;quot;)
  observer.onCompleted()
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは冒頭に出て来たObservableです．Schedulersを利用すれば簡単にノンブロッキングYO!YO!が出来ます．以上です．&lt;/p&gt;

&lt;p&gt;ソースコードは&lt;a href=&#34;https://gist.github.com/chooblarin/a041328422870581c616f32717d80393&#34;&gt;Gist&lt;/a&gt; に置いておきます．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md&#34;&gt;RxSwift/Schedulers.md at master · ReactiveX/RxSwift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftpearls.com/RxSwift-for-dummies-2-Operators.html&#34;&gt;RxSwift For Dummies 🐥 Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow入門以前</title>
      <link>http://chooblarin.github.io/post/getting-started-tensorflow/</link>
      <pubDate>Tue, 16 Aug 2016 21:00:25 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/getting-started-tensorflow/</guid>
      <description>

&lt;p&gt;ずっと気になっていた&lt;a href=&#34;https://www.tensorflow.org/&#34;&gt;TensorFlow&lt;/a&gt;を触ってみました．
TensorFlowの情報は既にWeb上で大量に溢れかえっていてとてもありがたかったです．
&lt;a href=&#34;http://qiita.com/search?q=tensorflow&#34;&gt;Qiitaでのキーワード検索結果&lt;/a&gt;は執筆時点で472件です．
大いに参考にさせて頂きました．&lt;/p&gt;

&lt;p&gt;ちなみに私は少し前から機械学習をこそこそと勉強しているアプリエンジニアです．&lt;/p&gt;

&lt;p&gt;実験環境は下記．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python: &lt;code&gt;3.5.1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TensorFlow: &lt;code&gt;0.10.0rc0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;※ニューラルネットワークはでてきません&lt;/p&gt;

&lt;h2 id=&#34;tensorflowの基礎知識&#34;&gt;TensorFlowの基礎知識&lt;/h2&gt;

&lt;p&gt;TensorFlowは一連の計算を&lt;a href=&#34;https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)&#34;&gt;グラフ&lt;/a&gt;で表現します．
&amp;ldquo;&lt;strong&gt;Operation&lt;/strong&gt;&amp;ldquo;と呼ばれるものがグラフのノードです．
Operationは0個以上の計算対象を受け取って0個以上の計算結果を生成します．
計算結果と計算対象は，&lt;strong&gt;Tensor&lt;/strong&gt; と呼ばれる多次元配列です (物理や数学でのテンソルと同義)．
Tensorはグラフのエッジに相当します．
このOperationを複数つなぎ合わせて所望の結果を得るようです．
このようにグラフで表された計算を，実行するには，&lt;strong&gt;Session&lt;/strong&gt; オブジェクトを利用します．
また，学習の状態を保存するために，&lt;strong&gt;Variable&lt;/strong&gt; を使うようです．&lt;/p&gt;

&lt;p&gt;↓ドキュメントをパラパラっと見てイメージを掴むと良さそうです．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/framework.html#Graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/framework.html#Operation&#34;&gt;Operations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/framework.html#Tensor&#34;&gt;Tensors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/client.html#Session&#34;&gt;Sessions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/state_ops.html&#34;&gt;Variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introductionをやってみる&#34;&gt;Introductionをやってみる&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/get_started/index.html&#34;&gt;公式のGET STARTED&lt;/a&gt;では
一次関数 $y = Wx + b$ について，$W$ と $b$ を最小二乗法で求めるサンプルが公開されていました．
（ちなみに $W$ はweight, $b$ はbiasです．）&lt;/p&gt;

&lt;p&gt;上述の基礎知識を思い出しつつコードを眺めると，やっていることが大体理解出来ました．
（ここでさっぱりイメージが湧かない人は，おそらく機械学習に関する知識が不足していますのでどこかで補いましょう．）&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Exampleの多くが&lt;a href=&#34;http://yann.lecun.com/exdb/mnist/&#34;&gt;MNIST&lt;/a&gt;の手書き数字画像を用いたものになっています．
素晴らしいExampleなのですがもう少し単純なもので試したい気もします．
今回は&lt;a href=&#34;https://archive.ics.uci.edu/ml/datasets/Iris&#34;&gt;Iris Data Set&lt;/a&gt;を使います．
アルゴリズムは機械学習で最も単純な&lt;a href=&#34;https://ja.wikipedia.org/wiki/K%E8%BF%91%E5%82%8D%E6%B3%95&#34;&gt;最近傍法&lt;/a&gt;を用います．&lt;/p&gt;

&lt;p&gt;下記は&lt;a href=&#34;https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/nearest_neighbor.ipynb&#34;&gt;こちらのサンプルコード&lt;/a&gt;をIris版に書きなおしたものです．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-

import random
import numpy as np
import tensorflow as tf
from sklearn import datasets

iris = datasets.load_iris()

n_sample = list(range(len(iris.data)))
random.seed(0)
random.shuffle(n_sample)

n_train = n_sample[:100]
n_test = n_sample[100:]

X_train = [iris.data[i] for i in n_train]
Y_train = [iris.target[i] for i in n_train]

X_test = [iris.data[i] for i in n_test]
Y_test = [iris.target[i] for i in n_test]

x_train = tf.placeholder(&amp;quot;float&amp;quot;, [None, 4])
x_test = tf.placeholder(&amp;quot;float&amp;quot;, [4])

distance = tf.reduce_sum(tf.abs(tf.add(x_train, tf.neg(x_test))), reduction_indices=1)
prediction = tf.arg_min(distance, 0)

accuracy = 0

init = tf.initialize_all_variables()

with tf.Session() as sess:
    sess.run(init)

    for i in range(len(X_test)):
        nn_index = sess.run(prediction, feed_dict={x_train: X_train, x_test: X_test[i]})
        pred = Y_train[nn_index]
        cls = Y_test[i]
        print(&amp;quot;Test&amp;quot;, i, &amp;quot;Prediction:&amp;quot;, pred, &amp;quot;True Class:&amp;quot;, cls)

        if pred == cls:
            accuracy += 1./len(X_test)
    print(&amp;quot;Done.&amp;quot;)
    print(&amp;quot;Accuracy:&amp;quot;, accuracy)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Test 0 Prediction: 0 True Class: 0
Test 1 Prediction: 1 True Class: 1
Test 2 Prediction: 2 True Class: 1
Test 3 Prediction: 2 True Class: 2
Test 4 Prediction: 1 True Class: 1
Test 5 Prediction: 1 True Class: 1
Test 6 Prediction: 1 True Class: 1
Test 7 Prediction: 0 True Class: 0
Test 8 Prediction: 0 True Class: 0
Test 9 Prediction: 2 True Class: 2
Test 10 Prediction: 2 True Class: 2
Test 11 Prediction: 0 True Class: 0
Test 12 Prediction: 0 True Class: 0
Test 13 Prediction: 2 True Class: 2
Test 14 Prediction: 2 True Class: 2
Test 15 Prediction: 1 True Class: 1
Test 16 Prediction: 1 True Class: 1
Test 17 Prediction: 2 True Class: 1
Test 18 Prediction: 0 True Class: 0
Test 19 Prediction: 2 True Class: 2
Test 20 Prediction: 1 True Class: 1
Test 21 Prediction: 1 True Class: 1
Test 22 Prediction: 0 True Class: 0
Test 23 Prediction: 2 True Class: 2
Test 24 Prediction: 0 True Class: 0
Test 25 Prediction: 0 True Class: 0
Test 26 Prediction: 1 True Class: 1
Test 27 Prediction: 2 True Class: 2
Test 28 Prediction: 1 True Class: 1
Test 29 Prediction: 0 True Class: 0
Test 30 Prediction: 0 True Class: 0
Test 31 Prediction: 1 True Class: 1
Test 32 Prediction: 0 True Class: 0
Test 33 Prediction: 1 True Class: 1
Test 34 Prediction: 0 True Class: 0
Test 35 Prediction: 2 True Class: 2
Test 36 Prediction: 2 True Class: 1
Test 37 Prediction: 0 True Class: 0
Test 38 Prediction: 2 True Class: 2
Test 39 Prediction: 1 True Class: 1
Test 40 Prediction: 1 True Class: 1
Test 41 Prediction: 2 True Class: 2
Test 42 Prediction: 1 True Class: 1
Test 43 Prediction: 2 True Class: 2
Test 44 Prediction: 2 True Class: 2
Test 45 Prediction: 2 True Class: 2
Test 46 Prediction: 1 True Class: 1
Test 47 Prediction: 0 True Class: 0
Test 48 Prediction: 2 True Class: 2
Test 49 Prediction: 1 True Class: 1
Done.
Accuracy: 0.94
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今日はここまで．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tensorflow.org/&#34;&gt;TensorFlow — an Open Source Software Library for Machine Intelligence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yanosen_jp/items/70e6d6afc36e1c0a3ef3&#34;&gt;TensorFlowのキーコンセプト: Opノード、セッション、変数 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/icoxfog417/items/fb5c24e35a849f8e2c5d&#34;&gt;TensorFlowを算数で理解する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>NSLinguistic​Taggerで遊ぶ</title>
      <link>http://chooblarin.github.io/post/natural-lang-with-swift/</link>
      <pubDate>Sun, 14 Aug 2016 21:34:14 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/natural-lang-with-swift/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://realm.io/news/natural-language-processing-with-swift/&#34;&gt;&amp;ldquo;Natural Language Processing with Swift&amp;rdquo;&lt;/a&gt;という素晴らしいトークを拝見しました．トークの中では，ナイーブベイズ分類器を用いた簡易のスパムフィルタの実装が説明されています．
その中で&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSLinguisticTagger_Class/&#34;&gt;&lt;code&gt;NSLinguistic​Tagger&lt;/code&gt;&lt;/a&gt;という便利なクラスを知り，気になったので触ってみました．(環境はXcode 7.3.1, Swift 2.2です．)&lt;/p&gt;

&lt;h2 id=&#34;初期化する&#34;&gt;初期化する&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;NSLinguistic​Tagger&lt;/code&gt;の初期には&lt;code&gt;tagSchemes&lt;/code&gt;と&lt;code&gt;options&lt;/code&gt;を渡します．
型はそれぞれ&lt;code&gt;[String]&lt;/code&gt;と&lt;code&gt;Int&lt;/code&gt;です．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NSLinguistic​Tagger&lt;/code&gt;はなかなか多機能なやつで，&lt;code&gt;tagSchemes&lt;/code&gt;には用途に応じたパラメータを渡すことになります．これは後ほど調べるとして，今はとにかくテキトーに初期化してみます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let tagger = NSLinguisticTagger(tagSchemes: [NSLinguisticTagSchemeLexicalClass], options: 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tagSchemes&lt;/code&gt;はLexicalClass，&lt;code&gt;options&lt;/code&gt;は特に指定せずにインスタンスを取得出来ました．&lt;/p&gt;

&lt;h2 id=&#34;試す&#34;&gt;試す&lt;/h2&gt;

&lt;p&gt;先ほど初期化した&lt;code&gt;NSLinguistic​Tagger&lt;/code&gt;の簡単な使用例を見ていきます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let sentence = &amp;quot;I&#39;m Spider-man.&amp;quot;
let range = NSRange(location: 0, length: sentence.characters.count)

tagger.string = sentence

tagger.enumerateTagsInRange(
    range,
    scheme: NSLinguisticTagSchemeLexicalClass,
    options: .OmitWhitespace) { tag, tokenRange, _, _ in
        let start = sentence.startIndex.advancedBy(tokenRange.location)
        let end = sentence.startIndex.advancedBy(tokenRange.location + tokenRange.length)

        let token = sentence.substringWithRange(start ..&amp;lt; end)
        print(&amp;quot;\(token) (\(tag))&amp;quot;)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力結果は以下の通り．&lt;code&gt;()&lt;/code&gt;の中身が&lt;code&gt;tagger&lt;/code&gt;によって付加されたtagです．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I (Pronoun)
&#39;m (Verb)
Spider (Noun)
- (Dash)
man (Noun)
. (SentenceTerminator)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように文章の品詞分解が出来ました．&lt;/p&gt;

&lt;h2 id=&#34;tagging-schemes&#34;&gt;Tagging Schemes&lt;/h2&gt;

&lt;p&gt;Schemeの指定を変更することで様々な結果を得ることが出来ます．(上記の例ではLexicalClassを指定しました．)&lt;/p&gt;

&lt;p&gt;英語のテキストに対して指定可能なSchemeの一覧は以下のように取得出来ます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let availableSchemes = NSLinguisticTagger.availableTagSchemesForLanguage(&amp;quot;en&amp;quot;)
// =&amp;gt; [&amp;quot;TokenType&amp;quot;, &amp;quot;Language&amp;quot;, &amp;quot;Script&amp;quot;, &amp;quot;Lemma&amp;quot;, &amp;quot;LexicalClass&amp;quot;, &amp;quot;NameType&amp;quot;, &amp;quot;NameTypeOrLexicalClass&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;試しに別なSchemeを指定して，先ほどのコードを実行してみます．（結果のみ）&lt;/p&gt;

&lt;h3 id=&#34;tokentype&#34;&gt;TokenType&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;I (Word)
&#39;m (Word)
Spider (Word)
- (Punctuation)
man (Word)
. (Punctuation)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nametype&#34;&gt;NameType&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;I (OtherWord)
&#39;m (OtherWord)
Spider (OtherWord)
- (Dash)
man (OtherWord)
. (SentenceTerminator)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;language&#34;&gt;Language&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;I (en)
&#39;m (en)
Spider (en)
- ()
man (en)
. ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と，このように異なるtaggingがされていることが分かります．&lt;/p&gt;

&lt;p&gt;Tag Schemesの一覧は&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSLinguisticTagger_Class/#//apple_ref/doc/constant_group/Linguistic_Tag_Schemes&#34;&gt;公式ドキュメント&lt;/a&gt;を確認して下さい．&lt;/p&gt;

&lt;h2 id=&#34;options&#34;&gt;Options&lt;/h2&gt;

&lt;p&gt;上記の例ではOmitWhitespaceを指定していたので空白の除去が行われていました．&lt;/p&gt;

&lt;p&gt;Optionsの一覧は&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSLinguisticTagger_Class/#//apple_ref/c/tdef/NSLinguisticTaggerOptions&#34;&gt;公式ドキュメント&lt;/a&gt;を確認して下さい．&lt;/p&gt;

&lt;p&gt;句読点の除去を行うOmitPunctuationや&amp;rdquo;New York&amp;rdquo;などを一単語として扱うJoinNamesなどがあります．&lt;/p&gt;

&lt;p&gt;複数のoptionを指定したい場合はor演算&lt;code&gt;|&lt;/code&gt;を行います．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let optionsRawValue: UInt =
NSLinguisticTaggerOptions.OmitWhitespace.rawValue | NSLinguisticTaggerOptions.JoinNames.rawValue

let optionsInt = Int(optionsRawValue)
let options = NSLinguisticTaggerOptions(rawValue: optionsRawValue)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;遊ぶ&#34;&gt;遊ぶ&lt;/h2&gt;

&lt;p&gt;では最後にサンプルコードを掲載します．Playgroundでそのまま実行出来るはずです．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;import Foundation

extension NSRange {
    func rangeForString(string: String) -&amp;gt; Range&amp;lt;String.Index&amp;gt;? {
        guard location != NSNotFound else { return nil }
        let start = string.startIndex.advancedBy(location)
        let end = string.startIndex.advancedBy(location + length)
        return start ..&amp;lt; end
    }
}

let sentence1 = &amp;quot;With great power comes great responsibility.&amp;quot;
let sentence2 = &amp;quot;In critical moments, men sometimes see exactly what they wish to see.&amp;quot;
let sentence3 = &amp;quot;He can make the choice that no one else can make, the right choice.&amp;quot;

let availableSchemes = NSLinguisticTagger.availableTagSchemesForLanguage(&amp;quot;en&amp;quot;)
let optionsRawValue: UInt =
    NSLinguisticTaggerOptions.OmitWhitespace.rawValue | NSLinguisticTaggerOptions.JoinNames.rawValue

let tagger = NSLinguisticTagger(tagSchemes: availableSchemes, options: Int(optionsRawValue))

for sentence in [sentence1, sentence2, sentence3] {
    tagger.string = sentence

    let range = NSRange(location: 0, length: sentence.characters.count)
    tagger.enumerateTagsInRange(
        range,
        scheme: NSLinguisticTagSchemeNameTypeOrLexicalClass,
        options: NSLinguisticTaggerOptions(rawValue: optionsRawValue)) {
            tag, tokenRange, sentenceRange, stop in
            let token = sentence.substringWithRange(tokenRange.rangeForString(sentence)!)
            print(&amp;quot;\(tag): \(token)&amp;quot;)
    }
    print(&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSLinguisticTagger_Class/&#34;&gt;NSLinguisticTagger Class Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://realm.io/jp/news/natural-language-processing-with-swift/&#34;&gt;Natural Language Processing with Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nshipster.com/nslinguistictagger/&#34;&gt;NSLinguisticTagger - NSHipster&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>RxJavaのconcatMapEager</title>
      <link>http://chooblarin.github.io/post/20160529/</link>
      <pubDate>Sun, 29 May 2016 22:18:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/20160529/</guid>
      <description>

&lt;p&gt;少し前の出来事なので忘れかけています．完全に忘れる前にブログに残しておきます．&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;あるとき，Androidアプリの開発でこんなコードを書いていました．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;というModelがある．&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;はID文字列&lt;code&gt;id&lt;/code&gt;をプロパティとしてもっている．&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;のランキングデータを取得するWeb APIが用意されていて&lt;code&gt;Item&lt;/code&gt;の&lt;code&gt;id&lt;/code&gt;の一覧が取得出来る．&lt;/li&gt;
&lt;li&gt;但し，取得出来るのは&lt;code&gt;id&lt;/code&gt;のみなのでViewに表示するデータ(Itemの詳細)は別のAPIで取得する必要がある．&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;flatmap&#34;&gt;flatMap()&lt;/h2&gt;

&lt;p&gt;最初，私は&lt;code&gt;Observable#flatMap()&lt;/code&gt;を使って以下のようにしました．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;requestRankingItems()
    .flatMap(itemId -&amp;gt; requestItem(itemId))
    .subscribe(item -&amp;gt; { /* bind item to view */ })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしこのコードには問題があります．私はランキング情報をViewに表示させたかったに，これではランキングの順番がバラバラになってしまいます．
&lt;a href=&#34;http://reactivex.io/documentation/operators/flatmap.html&#34;&gt;flatMap&lt;/a&gt;というオペレータは，
順番を保存しないからです．
上の例では&lt;code&gt;requestItem(itemId)&lt;/code&gt;でサーバにリクエストして，レスポンスが返ってきた順番に値がemitされます．
&lt;a href=&#34;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&#34;&gt;こちらの記事&lt;/a&gt;がとても参考になります．&lt;/p&gt;

&lt;h2 id=&#34;concatmap&#34;&gt;concatMap()&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Observable#concatMap()&lt;/code&gt;は&lt;code&gt;Observable#flatMap()&lt;/code&gt;と違って順番を保存してくれます．
そこで，コードをこのように変更してみました．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;requestRankingItems()
    .concatMap(itemId -&amp;gt; requestItem(itemId))
    .subscribe(item -&amp;gt; { /* bind item to view */ })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ところが，ここで別の問題があります．&lt;code&gt;concatMap()&lt;/code&gt;は，ソースObservableの値を1つずつ処理します．
現在の値の処理が完了するまで次の処理を行わないのです．つまり，上の例の場合，&lt;code&gt;requestItem(itemId)&lt;/code&gt;でサーバにリクエストは，レスポンスが返ってくるまで次のリクエストを行わないのです．
これでは，1リクエスト1秒掛かるとすると，20件のItemを取得するのに20秒も待たなければなりません．&lt;/p&gt;

&lt;p&gt;リクエストは並列で実行して，結果は順番通りに取得したいんですよ．
Javascriptの&lt;code&gt;Promise.all()&lt;/code&gt;のように．
&lt;a href=&#34;http://stackoverflow.com/questions/35339190/is-there-a-way-like-promise-all-in-rxjava&#34;&gt;StackOverflow&lt;/a&gt;でも質問をしてみましたが期待した答えはもらえませんでした．&lt;/p&gt;

&lt;h2 id=&#34;concatmapeager&#34;&gt;concatMapEager()&lt;/h2&gt;

&lt;p&gt;RxJavaのObservableに&lt;code&gt;concatMapEager&lt;/code&gt;というオペレーターがあります．
&lt;a href=&#34;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMapEager(rx.functions.Func1)&#34;&gt;ドキュメント&lt;/a&gt;にはこう記されています．
&amp;gt; Maps a sequence of values into Observables and concatenates these Observables eagerly into a single Observable.&lt;/p&gt;

&lt;p&gt;どうやらeagerlyにconcatしてくれるらしいです．
更に&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the source Observables. The operator buffers the values emitted by these Observables and then drains them in order, each one after the previous one completes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;concatMapEagerではソースObservable（上の例ではitemIdのObservable）をすべてsubscribeしてくれます．
つまり，すべてのidに対して一気にリクエストしてくれます．しかも結果はバッファリングされて，順番通りにemitされます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;requestRankingItems()
    .concatMapEager(itemId -&amp;gt; requestItem(itemId))
    .subscribe(item -&amp;gt; { /* bind item to view */ })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでOKです．ただし&lt;code&gt;concatMapEager&lt;/code&gt;はExperimentalですので今後も注目です．&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;「ブログに書く」という行為をすっかり忘れて暮らしていました．アウトプットはきちんと習慣化したいものですね．&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1)&#34;&gt;flatMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&#34;&gt;concatMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMapEager(rx.functions.Func1)&#34;&gt;concatMapEager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&#34;&gt;RxJava Observable tranformation: concatMap() vs flatMap()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveX/reactivex.github.io/issues/165&#34;&gt;Document new concatEager() operator #165&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Hello PhoenixをHerokuで</title>
      <link>http://chooblarin.github.io/post/20150828/</link>
      <pubDate>Fri, 28 Aug 2015 07:15:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/20150828/</guid>
      <description>

&lt;p&gt;つい先日弊社ではElixirの&lt;a href=&#34;https://gist.github.com/chooblarin/2432345f7b11629bafd9&#34;&gt;社内勉強会&lt;/a&gt;を行いました．&lt;/p&gt;

&lt;p&gt;今回は&lt;a href=&#34;http://www.phoenixframework.org&#34;&gt;Phoenix&lt;/a&gt;をHerokuで動かしてみます．&lt;/p&gt;

&lt;p&gt;以下のサイトを参考にさせてもらいました．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wsmoak.net/2015/07/05/phoenix-on-heroku.html&#34;&gt;Deploying a Phoenix app to Heroku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;phoenixをインストール&#34;&gt;Phoenixをインストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.phoenixframework.org/docs/installation&#34;&gt;公式サイト&lt;/a&gt;に記載の通りです．&lt;/p&gt;

&lt;p&gt;Hexをインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix local.hex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phoenixアーカイブをインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix archive.install https://github.com/phoenixframework/phoenix/releases/download/v0.17.1/phoenix_new-0.17.1.ez
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hello-phoenix&#34;&gt;Hello Phoenix&lt;/h2&gt;

&lt;p&gt;これも&lt;a href=&#34;http://www.phoenixframework.org/docs/up-and-running&#34;&gt;公式サイト&lt;/a&gt;通り．&lt;/p&gt;

&lt;p&gt;Phoenixプロジェクトを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phoenix.new hello_phoenix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd hello_phoenix
$ mix phoenix.server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;確認 =&amp;gt; &lt;a href=&#34;http://localhost:4000&#34;&gt;http://localhost:4000&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;herokuにデプロイ&#34;&gt;Herokuにデプロイ&lt;/h2&gt;

&lt;p&gt;Buildpackに&lt;a href=&#34;https://github.com/HashNuke/heroku-buildpack-elixir&#34;&gt;Heroku Buildpack for Elixir&lt;/a&gt;と&lt;a href=&#34;https://github.com/gjaldon/heroku-buildpack-phoenix-static&#34;&gt;Phoenix Static Buildpack&lt;/a&gt;の2つを使用します．&lt;/p&gt;

&lt;h3 id=&#34;gitignoreファイルを編集&#34;&gt;.gitignoreファイルを編集&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;の&lt;code&gt;config/prod.secret.exs&lt;/code&gt;をコメントアウトします．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...

# The config/prod.secret.exs file by default contains sensitive
# data and you should not commit it into version control.
#
# Alternatively, you may comment the line below and commit the
# secrets file as long as you replace its contents by environment
# variables.
#/config/prod.secret.exs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;herokuの環境編集を設定&#34;&gt;Herokuの環境編集を設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;config/prod.secret.exs&lt;/code&gt;を&lt;code&gt;.gitignore&lt;/code&gt;の対象から外したので，重要な情報をherokuの環境変数に置き換えます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

# In this file, we keep production configuration that
# you likely want to automate and keep it away from
# your version control system.
config :hello_phoenix_heroku, HelloPhoenixHeroku.Endpoint,
  secret_key_base: System.get_env(&amp;quot;SECRET_KEY_BASE&amp;quot;)

# Configure your database
config :hello_phoenix_heroku, HelloPhoenixHeroku.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: System.get_env(&amp;quot;DATABASE_USERNAME&amp;quot;),
  password: System.get_env(&amp;quot;DATABASE_PASSWORD&amp;quot;),
  database: &amp;quot;hello_phoenix_heroku_prod&amp;quot;,
  size: 20 # The amount of database connections in the pool
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ heroku config:set SECRET_KEY_BASE=&amp;lt;YOUR_SECRET_KEY_BASE&amp;gt;
$ heroku config:set SECRET_KEY_BASE=&amp;lt;YOUR_DATABASE_USERNAME&amp;gt;
$ heroku config:set SECRET_KEY_BASE=&amp;lt;YOUR_DATABASE_PASSWORD&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;必要な設定ファイルを作成&#34;&gt;必要な設定ファイルを作成&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;elixir_buildpack.config&lt;/code&gt;ファイルと&lt;code&gt;Procfile&lt;/code&gt;をプロジェクトのルートに作成します．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;elixir_buildpack.config&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# Erlang version
erlang_version=17.5

# Elixir version
elixir_version=1.0.4

# Always rebuild from scratch on every deploy?
always_rebuild=false

# Export heroku config vars
config_vars_to_export=(DATABASE_URL SECRET_KEY_BASE)

# A command to run right after compiling the app
post_compile=&amp;quot;pwd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Procfile&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;web: mix phoenix.server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたらgitコミットします．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init
$ git add .
$ git commit -m &amp;quot;Hello, Phoenix&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;デプロイ&#34;&gt;デプロイ&lt;/h3&gt;

&lt;p&gt;Herokuアプリを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku create --buildpack &amp;quot;https://github.com/HashNuke/heroku-buildpack-elixir.git&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下の2つのBuildpackを設定&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/HashNuke/heroku-buildpack-elixir&#34;&gt;Heroku Buildpack for Elixir&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gjaldon/heroku-buildpack-phoenix-static&#34;&gt;Phoenix Static Buildpack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ heroku buildpacks:set https://github.com/gjaldon/phoenix-static-buildpack
$ heroku buildpacks:add --index 1 https://github.com/HashNuke/heroku-buildpack-elixir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ぷっしゅ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://chooblaphoenix.herokuapp.com&#34;&gt;出来た！&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>今年はElixir</title>
      <link>http://chooblarin.github.io/post/20150703/</link>
      <pubDate>Fri, 03 Jul 2015 03:15:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/20150703/</guid>
      <description>&lt;p&gt;毎年新しいプログラミング言語を勉強しろと誰かが言っていました．
今年は流行に乗って&lt;a href=&#34;http://elixir-lang.org/&#34;&gt;Elixir&lt;/a&gt;をコツコツ勉強しようと思います．
&lt;a href=&#34;http://www.phoenixframework.org/v0.10.0&#34;&gt;Phoenix Framework&lt;/a&gt;で何かしらのアプリを作ることを目標にします．&lt;/p&gt;

&lt;p&gt;千里の道も&lt;a href=&#34;http://chooblarin.com/slides/?elixir_intro_01.md&#34;&gt;一歩&lt;/a&gt;から&lt;/p&gt;

&lt;p&gt;Peace out!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>宮崎マンゴー</title>
      <link>http://chooblarin.github.io/post/20150620/</link>
      <pubDate>Sat, 20 Jun 2015 16:12:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/20150620/</guid>
      <description>

&lt;p&gt;マンゴーを初めて食べた記録です&lt;/p&gt;

&lt;h2 id=&#34;太陽のタマゴを知った&#34;&gt;太陽のタマゴを知った&lt;/h2&gt;

&lt;p&gt;先日Twitterを眺めていると，タイムラインにおいしそうな*宮崎県産完熟マンゴー太陽のタマゴ*が流れてきた．&lt;/p&gt;

&lt;p&gt;宮崎県産完熟マンゴー太陽のタマゴとは
&amp;gt; 完全に熟して自然に枝から落ちたところを、かぶせていたネットで収穫する。糖度15度以上、重さ350グラム以上で色づきも良いものが「太陽のタマゴ」と呼ばれる。県内では完熟マンゴーは約600トン生産されており(2009年)、そのうち「太陽のタマゴ」は15%ほど。
（出典: &lt;a href=&#34;https://kotobank.jp/word/%E5%AE%AE%E5%B4%8E%E7%9C%8C%E7%94%A3%E5%AE%8C%E7%86%9F%E3%83%9E%E3%83%B3%E3%82%B4%E3%83%BC%E5%A4%AA%E9%99%BD%E3%81%AE%E3%82%BF%E3%83%9E%E3%82%B4-889711&#34;&gt;コトバンク - 朝日新聞掲載「キーワード」&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;世の中の人間は，これを「食べた人」と「食べていない人」に分類されるらしい．食べてみたい．食べてみたい&amp;hellip;&lt;/p&gt;

&lt;p&gt;社員と食事をしているときにこの話をしたところ，昨日の朝会社のデスクを見ると&amp;hellip;なんと太陽のタマゴが&amp;hellip;！
会社の方が誕生日プレゼントで買ってきてくれた．感謝感激雨霰嵐．生きててよかった〜&lt;/p&gt;

&lt;p&gt;というわけでさっそく&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;マンゴー食す&lt;/p&gt;&amp;mdash; はたけやまそうた (@chooblarin) &lt;a href=&#34;https://twitter.com/chooblarin/status/612142992275582976&#34;&gt;2015, 6月 20&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;開封の儀&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/ecw2csk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;オープン！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/wVHt5um.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;なんと美しい果実．
この真っ赤な色に傷一つ付いていない表面．滑らかな湾曲美．一体何回微分可能なんだ．&lt;/p&gt;

&lt;p&gt;入刀の儀&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/7Hj3t1O.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/R3Gy2Ug.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;はあ&amp;hellip;うまそう&lt;/p&gt;

&lt;p&gt;いざ，実食&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/Hd0Elgq.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/WkMDiht.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/xIeJTQH.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/UG33htO.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;太陽のタマゴはむちゃくちゃうまい&lt;/p&gt;

&lt;p&gt;ありがとうございました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Milestone</title>
      <link>http://chooblarin.github.io/post/to_be_an_android_developer/</link>
      <pubDate>Sat, 13 Jun 2015 14:38:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/to_be_an_android_developer/</guid>
      <description>

&lt;p&gt;プログラマになってからおよそ2年が経った節目にブログを書きました．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/kC5Qqj5.jpg&#34; alt=&#34;&#34; title=&#34;sf&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;これまで&#34;&gt;これまで&lt;/h1&gt;

&lt;p&gt;つい最近，GoogleIOやWWDCが終わりましたが，モバイルアプリの発展はとどまることを知らない状況に感じます．
初めて僕がAndroidのHelloWorldを動かした日から考えるとびっくりするほどの変化です．
ふと思い返すと，かれこれAndroid歴が1年を超えていました．
関わった全てのプロジェクト（前職では4つ，現職で2つ）でAndroidアプリを担当しました．
そろそろブログなどのアウトプットもしていこうかなあと考えています．&lt;/p&gt;

&lt;h1 id=&#34;近況&#34;&gt;近況&lt;/h1&gt;

&lt;p&gt;2015年の1月，新卒で入社した会社を辞めました．入社前にアルバイトをしていた期間を含めるとおよそ20ヶ月お世話になりました．
退職の理由は，先輩の経営している会社に転職して働くことに決めたからです．
転職からおよそ5ヶ月が経ちました．毎日充実しています．それなりに楽しくやっています．
業務内容は前職と同じで，Androidのアプリ開発をしています．
前職と大きく違う点は，ちょっとしたバックエンドの実装やリリース前の作業なども自分がコミットする点です．
会社も開発も規模があまり大きくないので，出来るところは自分でやることになっています．LPの制作なんかも初めてやりました．
アプリのリリース後もアップデート内容を考えて実装しています．本当に楽しい．&lt;/p&gt;

&lt;p&gt;今日もがんばろ&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Observableは友達</title>
      <link>http://chooblarin.github.io/post/observable_is_my_friend/</link>
      <pubDate>Tue, 17 Mar 2015 22:57:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/observable_is_my_friend/</guid>
      <description>

&lt;p&gt;この文章はRxJavaとRxAndroidについて書かれています．
開発中のAndroidアプリに導入してみて得られた知見をまったりざっくりまとめてみます．&lt;/p&gt;

&lt;h3 id=&#34;rxとリアクティブプログラミング&#34;&gt;Rxとリアクティブプログラミング&lt;/h3&gt;

&lt;p&gt;これについて解説している記事は既にたくさん（ここ最近では特に）あるので割愛します．
せっかくなので分かりやすかった記事をいくつかリンクします．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/&#34;&gt;Grokking RxJava&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://futurice.com/blog/top-7-tips-for-rxjava-on-android&#34;&gt;Top 7 Tips for RxJava on Android — Futurice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://steps.dodgson.org/b/2014/12/07/reactive-porn/&#34;&gt;Reactive Porn - steps to phantasien&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://okapies.hateblo.jp/entry/2015/03/04/031148&#34;&gt;関数型プログラマのための Rx 入門（前編） - Okapies&amp;rsquo; Archive&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;observableの生成&#34;&gt;Observableの生成&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki/Creating-Observables&#34;&gt;Observableの生成&lt;/a&gt;は複数の方法があります．
&lt;code&gt;create()&lt;/code&gt;を使うとあらゆるデータを&lt;code&gt;Observable&lt;/code&gt;にラップ出来ます．
ファイル読み書き，ローカルDBアクセス，ネットワーク通信に関連するデータはほとんど全て&lt;code&gt;create()&lt;/code&gt;を使ってObservableに出来ます．&lt;/p&gt;

&lt;p&gt;例えば，assetsフォルダの中の&amp;rdquo;hoge.json&amp;rdquo;からテキストを読み込んでくるときはこんなカンジ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Observable&amp;lt;JSONObject&amp;gt; load(final Context context) {
 return Observable
   .create((OnSubscribe&amp;lt;AppItem&amp;gt;) subscriber -&amp;gt; {
     InputStream inputStream = null;
     BufferedReader reader = null;
     StringBuilder buf = new StringBuilder();

     try {
       inputStream = context.getAssets().open(&amp;quot;hoge.json&amp;quot;);
       reader = new BufferedReader(new InputStreamReader(inputStream));
       String str;

       while ((str = inputStream.readLine()) != null) {
         buf.append(str);
       }
       subscriber.onNext(new JSONObject(buf.toString()));
       subscriber.onComplete();

     } catch (JSONException | IOException e) {
       subscriber.onError(e);

     } finally {
       try {
         if (inputStream != null) {
           inputStream.close();
         }
         if (reader != null) {
           reader.close();
         }
       } catch (IOException ignored) {}
     }
   });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し側ではこんなカンジ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dataService.load(context)
  .subscribeOn(Schedulers.io())
  .observeOn(AndroidSchedulers.mainThread())
  .subscribe(
    _jsonObject -&amp;gt; {
      bindData(_jsonObject);
    },
    error -&amp;gt; {
      // error handling
    }
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカルDBへのアクセスも．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  Observable
    .create(subscriber -&amp;gt; {
      try {
        /* データを取得して */
        onNext(data); /* データをemit */

      } catch (Exception e) {
        /* エラー処理があればやっておく．トランザクションのキャンセル処理など */
        subscriber.onError(e);
      } finally {
        /* 後始末 */
      }

      subscriber.onCompleted();
    })
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(observer);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hotとcold&#34;&gt;HotとCold&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Hot   ･･･ subscribeされていなくても値をemitする．&lt;/li&gt;
&lt;li&gt;Cold  ･･･ &lt;code&gt;subscribe()&lt;/code&gt;が呼ばれるまで値をemitしない．&lt;code&gt;subscribe()&lt;/code&gt;毎に新しく値をemitする．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;subscriberが値をemitしはじめるのは，そのObservableがsubscribeされてからです．つまり，&lt;code&gt;subscribe()&lt;/code&gt;が呼ばれるまでは何も起こりません．
更に，Observableはsubscribeが呼ばれる度に値を&lt;code&gt;create&lt;/code&gt;のオペレーターが実行されます．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/toRisouP/items/f6088963037bfda658d3&#34;&gt;この記事&lt;/a&gt;がわかりやすいです．&lt;/p&gt;

&lt;p&gt;例えば以下のようにファイルから読み込んだデータを複数のObserverがsubscribeしたいとします．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Observable&amp;lt;JSONObject&amp;gt; jsonObject
  = dataService
      .load()
      .subscribeOn(Schedulers.io())
      .observeOn(AndroidSchedulers.mainThread());

jsonObject.subscribe(observer1);

jsonObject.subscribe(observer2); // 無駄にファイルを読み直している
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この例では，同じデータなのに2回もファイルを読みにいってしまいます．
Subjectを使うとHotなObservableでこの問題を解決出来ます．先ほどの例をこんなカンジに変えてみます．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PublishSubject&amp;lt;JsonObject&amp;gt; subject = PublishSubject.create();

subject.asObservable().subscribe(observer1);
subject.asObservable().subscribe(observer2);

Observable&amp;lt;JSONObject&amp;gt; jsonObject
  = dataService
      .load()
      .subscribeOn(Schedulers.io())
      .observeOn(AndroidSchedulers.mainThread())
      .subscribe(subject);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上でした．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>