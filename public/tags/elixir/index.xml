<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elixir on chooblarin&#39;s blog</title>
    <link>http://chooblarin.github.io/tags/elixir/index.xml</link>
    <description>Recent content in Elixir on chooblarin&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 chooblarin</copyright>
    <atom:link href="http://chooblarin.github.io/tags/elixir/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ElixirでMIDIファイルをパースする</title>
      <link>http://chooblarin.github.io/post/parsing-midi-by-elixir/</link>
      <pubDate>Sat, 26 Aug 2017 23:28:44 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/parsing-midi-by-elixir/</guid>
      <description>

&lt;h2 id=&#34;動機&#34;&gt;動機&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://chooblarin.github.io/post/trying-beat-detection/&#34;&gt;前回のエントリ&lt;/a&gt;では，音楽に合わせて何か絵を動かそうとしてbeat detectionを行いましたが，事前に音に関する情報を分析するアプローチにも挑戦して見たいと思っていたところ，MIDIファイルならElixirの勉強に丁度良いかもと思いついてこの記事を書きました．&lt;/p&gt;

&lt;h2 id=&#34;midi&#34;&gt;MIDI&lt;/h2&gt;

&lt;p&gt;MIDIは音の情報の形式の一つです．MIDIの最も一般的なファイルがSMF(Standard MIDI Format)です．以降，SMFのファイルを単に「MIDIファイル」と表記します．&lt;/p&gt;

&lt;h2 id=&#34;elixir&#34;&gt;Elixir&lt;/h2&gt;

&lt;p&gt;Elixirのパターンマッチは素晴らしいです．バイナリもパターンマッチ出来ます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(1)&amp;gt; &amp;lt;&amp;lt;header :: 8, data :: binary&amp;gt;&amp;gt; = &amp;lt;&amp;lt;1, 2, 3, 4, 5&amp;gt;&amp;gt;        
&amp;lt;&amp;lt;1, 2, 3, 4, 5&amp;gt;&amp;gt;
iex(2)&amp;gt; header
1
iex(3)&amp;gt; data
&amp;lt;&amp;lt;2, 3, 4, 5&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;やってみる&#34;&gt;やってみる&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://maruyama.breadfish.jp/tech/smf&#34;&gt;こちらを&lt;/a&gt;参考にMIDIファイルの中身を覗いてみる．&lt;/p&gt;

&lt;p&gt;まず，MIDIファイルを読み込みます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(1) {:ok, data} = File.read &#39;sample.midi&#39;
{:ok,
 &amp;lt;&amp;lt;77, 84, 104, 100, 0, 0, 0, 6, 0, 1, 0, 20, 1, 224, 77, 84, 114, 107, 0, 0, 0,
   36, 0, 255, 3, 3, 82, 101, 105, 0, 255, 81, 3, 7, 161, 32, 0, 255, 88, 4, 4,
   2, 24, 8, 143, 143, 0, 255, 88, ...&amp;gt;&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バイナリさんこんにちわ．MIDIファイルは必ずヘッダチャンクとトラックチャンクで構成されています．&lt;/p&gt;

&lt;h3 id=&#34;ヘッダ&#34;&gt;ヘッダ&lt;/h3&gt;

&lt;p&gt;ヘッダを覗いてみます．ヘッダのチャンク構成は以下のようになっています．括弧の数字はバイト数です．&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;lt;&amp;ldquo;MThd&amp;rdquo;&amp;gt; &amp;lt;データ長 (4)&amp;gt; &amp;lt;フォーマット (2)&amp;gt; &amp;lt;トラック数 (2)&amp;gt; &amp;lt;時間単位 (2)&amp;gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;パターンマッチを使うと一発でヘッダをパース出来ます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(2)&amp;gt; &amp;lt;&amp;lt;&amp;quot;MThd&amp;quot;, 6 :: size(32), format :: size(16), num_of_tracks :: size(16), time_unit :: size(16), rest :: binary&amp;gt;&amp;gt; = data
&amp;lt;&amp;lt;77, 84, 104, 100, 0, 0, 0, 6, 0, 1, 0, 20, 1, 224, 77, 84, 114, 107, 0, 0, 0,
  36, 0, 255, 3, 3, 82, 101, 105, 0, 255, 81, 3, 7, 161, 32, 0, 255, 88, 4, 4,
  2, 24, 8, 143, 143, 0, 255, 88, 4, ...&amp;gt;&amp;gt;

iex(3)&amp;gt; format
1
iex(4)&amp;gt; num_of_tracks
20
iex(5)&amp;gt; time_unit
480
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フォーマット1，トラック数20，時間単位480のようです．MIDIファイルのフォーマットは&amp;rdquo;0&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;の3種類が定義されています．フォーマット1はトラック構成を保存したフォーマットです (後にみていくと分かります)．このファイルは20トラックの情報を含んでいます．時間単位480の意味は，全音符の分解能が480という意味です．よくわからなくても気にせずに進みます．&lt;/p&gt;

&lt;p&gt;ここで&lt;code&gt;MidiParser&lt;/code&gt;というmoduleを定義しておきます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule MidiParser do

  def parse_header(&amp;lt;&amp;lt;
  &amp;quot;MThd&amp;quot;,
  6 :: size(32),
  format :: size(16),
  num_of_tracks :: size(16),
  time_unit :: size(16),
  _ :: binary&amp;gt;&amp;gt;) do

  IO.puts &amp;quot;format: #{format}&amp;quot;
  IO.puts &amp;quot;number of tracks: #{num_of_tracks}&amp;quot;
  IO.puts &amp;quot;time unit: #{time_unit}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;トラック&#34;&gt;トラック&lt;/h3&gt;

&lt;p&gt;トラックのチャンク構成は以下のようになっています．&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;lt;&amp;ldquo;MTrk&amp;rdquo;&amp;gt; &amp;lt;データ長 (4)&amp;gt; &amp;lt;データ本体&amp;gt; &amp;lt;&amp;hellip;残りのトラックデータ&amp;gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MidiParser&lt;/code&gt;に各トラックのデータ本体のバイナリを取得する関数を追加します．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule MidiParser do

  ...

  def parse_track(data) do
    _parse_track_chunk(data, [])
  end

  defp _parse_track_chunk(&amp;lt;&amp;lt;&amp;gt;&amp;gt;, acc) do
    Enum.reverse(acc)
  end

  defp _parse_track_chunk(&amp;lt;&amp;lt;
    &amp;quot;MTrk&amp;quot;,
    length :: size(32),
    body :: binary - size(length),
    chunks :: binary&amp;gt;&amp;gt;, tracks) do

    _parse_track_chunk(chunks, [body | tracks])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トラック部分のバイナリを渡して…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(7)&amp;gt; tracks = MidiParser.parse_track(chunks)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tracks&lt;/code&gt;はトラックの情報を持ったbinaryのリストです．長さを調べると…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iex(8)&amp;gt; length tracks
20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;20トラック分のバイナリを取得出来ました．これからトラック情報をパースしていきます．&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;lt;データ本体&amp;gt;&lt;/em&gt; は以下のような構成です．&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;lt;デルタタイム&amp;gt; &amp;lt;イベント&amp;gt; &amp;lt;デルタタイム&amp;gt; &amp;lt;イベント&amp;gt; &amp;lt;デルタタイム&amp;gt; &amp;lt;イベント&amp;gt;&amp;hellip;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;デルタタイムは可変長バイト列です．先頭1ビットはフラグで残りの7ビット分が数値を表しています．MSB(Most Significant Byte)が1のとき，次のバイトもデルタタイムを表現していることになります．この表現方法を解釈する関数を定義してみました．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def _extract_variable_length(&amp;lt;&amp;lt;msb :: 1, exp :: 7, _ :: binary&amp;gt;&amp;gt;) when msb == 0 do
  &amp;lt;&amp;lt;exp :: 7&amp;gt;&amp;gt;
end

def _extract_variable_length(&amp;lt;&amp;lt;_ :: 1, exp :: 7, rest :: binary&amp;gt;&amp;gt;) do
  next = _extract_variable_length(rest)
  &amp;lt;&amp;lt; &amp;lt;&amp;lt;exp :: 7&amp;gt;&amp;gt; :: bitstring, next :: bitstring &amp;gt;&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで数値部分のbitstringを抽出出来ました．バイト列に戻して値を抽出します．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def extract_variable_length(data) do
  bits = _extract_variable_length(data)
  bs = bit_size(bits)
  padding_size = 8 - rem(bs, 8)
  byte_data = &amp;lt;&amp;lt; &amp;lt;&amp;lt;0 :: size(padding_size)&amp;gt;&amp;gt; :: bitstring, bits :: bitstring &amp;gt;&amp;gt;

  bit_length = padding_size + bs
  &amp;lt;&amp;lt;length :: size(bit_length)&amp;gt;&amp;gt; = byte_data
  &amp;lt;&amp;lt;_ :: size(bit_length), chunks :: binary&amp;gt;&amp;gt; = data
  {length, chunks}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはイベントを解釈するコードを追加するのですが，長くなりそうなので続きは後日書きます．
ソースコードは&lt;a href=&#34;https://github.com/chooblarin/midi_parser&#34;&gt;こちら&lt;/a&gt;に置きました．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html&#34;&gt;Standard MIDI-File Format Spec. 1.1, updated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://maruyama.breadfish.jp/tech/smf&#34;&gt;SMF(Standard MIDI File)フォーマット解説 | 技術的読み物 | FISH&amp;amp;BREAD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zohaib.me/binary-pattern-matching-in-elixir/&#34;&gt;Binary pattern matching in Elixir with PNG parsing example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Hello PhoenixをHerokuで</title>
      <link>http://chooblarin.github.io/post/20150828/</link>
      <pubDate>Fri, 28 Aug 2015 07:15:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/20150828/</guid>
      <description>

&lt;p&gt;つい先日弊社ではElixirの&lt;a href=&#34;https://gist.github.com/chooblarin/2432345f7b11629bafd9&#34;&gt;社内勉強会&lt;/a&gt;を行いました．&lt;/p&gt;

&lt;p&gt;今回は&lt;a href=&#34;http://www.phoenixframework.org&#34;&gt;Phoenix&lt;/a&gt;をHerokuで動かしてみます．&lt;/p&gt;

&lt;p&gt;以下のサイトを参考にさせてもらいました．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wsmoak.net/2015/07/05/phoenix-on-heroku.html&#34;&gt;Deploying a Phoenix app to Heroku&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;phoenixをインストール&#34;&gt;Phoenixをインストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.phoenixframework.org/docs/installation&#34;&gt;公式サイト&lt;/a&gt;に記載の通りです．&lt;/p&gt;

&lt;p&gt;Hexをインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix local.hex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phoenixアーカイブをインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix archive.install https://github.com/phoenixframework/phoenix/releases/download/v0.17.1/phoenix_new-0.17.1.ez
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hello-phoenix&#34;&gt;Hello Phoenix&lt;/h2&gt;

&lt;p&gt;これも&lt;a href=&#34;http://www.phoenixframework.org/docs/up-and-running&#34;&gt;公式サイト&lt;/a&gt;通り．&lt;/p&gt;

&lt;p&gt;Phoenixプロジェクトを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phoenix.new hello_phoenix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd hello_phoenix
$ mix phoenix.server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;確認 =&amp;gt; &lt;a href=&#34;http://localhost:4000&#34;&gt;http://localhost:4000&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;herokuにデプロイ&#34;&gt;Herokuにデプロイ&lt;/h2&gt;

&lt;p&gt;Buildpackに&lt;a href=&#34;https://github.com/HashNuke/heroku-buildpack-elixir&#34;&gt;Heroku Buildpack for Elixir&lt;/a&gt;と&lt;a href=&#34;https://github.com/gjaldon/heroku-buildpack-phoenix-static&#34;&gt;Phoenix Static Buildpack&lt;/a&gt;の2つを使用します．&lt;/p&gt;

&lt;h3 id=&#34;gitignoreファイルを編集&#34;&gt;.gitignoreファイルを編集&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;の&lt;code&gt;config/prod.secret.exs&lt;/code&gt;をコメントアウトします．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...

# The config/prod.secret.exs file by default contains sensitive
# data and you should not commit it into version control.
#
# Alternatively, you may comment the line below and commit the
# secrets file as long as you replace its contents by environment
# variables.
#/config/prod.secret.exs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;herokuの環境編集を設定&#34;&gt;Herokuの環境編集を設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;config/prod.secret.exs&lt;/code&gt;を&lt;code&gt;.gitignore&lt;/code&gt;の対象から外したので，重要な情報をherokuの環境変数に置き換えます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

# In this file, we keep production configuration that
# you likely want to automate and keep it away from
# your version control system.
config :hello_phoenix_heroku, HelloPhoenixHeroku.Endpoint,
  secret_key_base: System.get_env(&amp;quot;SECRET_KEY_BASE&amp;quot;)

# Configure your database
config :hello_phoenix_heroku, HelloPhoenixHeroku.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: System.get_env(&amp;quot;DATABASE_USERNAME&amp;quot;),
  password: System.get_env(&amp;quot;DATABASE_PASSWORD&amp;quot;),
  database: &amp;quot;hello_phoenix_heroku_prod&amp;quot;,
  size: 20 # The amount of database connections in the pool
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ heroku config:set SECRET_KEY_BASE=&amp;lt;YOUR_SECRET_KEY_BASE&amp;gt;
$ heroku config:set SECRET_KEY_BASE=&amp;lt;YOUR_DATABASE_USERNAME&amp;gt;
$ heroku config:set SECRET_KEY_BASE=&amp;lt;YOUR_DATABASE_PASSWORD&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;必要な設定ファイルを作成&#34;&gt;必要な設定ファイルを作成&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;elixir_buildpack.config&lt;/code&gt;ファイルと&lt;code&gt;Procfile&lt;/code&gt;をプロジェクトのルートに作成します．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;elixir_buildpack.config&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# Erlang version
erlang_version=17.5

# Elixir version
elixir_version=1.0.4

# Always rebuild from scratch on every deploy?
always_rebuild=false

# Export heroku config vars
config_vars_to_export=(DATABASE_URL SECRET_KEY_BASE)

# A command to run right after compiling the app
post_compile=&amp;quot;pwd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Procfile&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;web: mix phoenix.server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたらgitコミットします．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init
$ git add .
$ git commit -m &amp;quot;Hello, Phoenix&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;デプロイ&#34;&gt;デプロイ&lt;/h3&gt;

&lt;p&gt;Herokuアプリを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku create --buildpack &amp;quot;https://github.com/HashNuke/heroku-buildpack-elixir.git&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下の2つのBuildpackを設定&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/HashNuke/heroku-buildpack-elixir&#34;&gt;Heroku Buildpack for Elixir&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gjaldon/heroku-buildpack-phoenix-static&#34;&gt;Phoenix Static Buildpack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ heroku buildpacks:set https://github.com/gjaldon/phoenix-static-buildpack
$ heroku buildpacks:add --index 1 https://github.com/HashNuke/heroku-buildpack-elixir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ぷっしゅ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://chooblaphoenix.herokuapp.com&#34;&gt;出来た！&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>今年はElixir</title>
      <link>http://chooblarin.github.io/post/20150703/</link>
      <pubDate>Fri, 03 Jul 2015 03:15:00 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/20150703/</guid>
      <description>&lt;p&gt;毎年新しいプログラミング言語を勉強しろと誰かが言っていました．
今年は流行に乗って&lt;a href=&#34;http://elixir-lang.org/&#34;&gt;Elixir&lt;/a&gt;をコツコツ勉強しようと思います．
&lt;a href=&#34;http://www.phoenixframework.org/v0.10.0&#34;&gt;Phoenix Framework&lt;/a&gt;で何かしらのアプリを作ることを目標にします．&lt;/p&gt;

&lt;p&gt;千里の道も&lt;a href=&#34;http://chooblarin.com/slides/?elixir_intro_01.md&#34;&gt;一歩&lt;/a&gt;から&lt;/p&gt;

&lt;p&gt;Peace out!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>