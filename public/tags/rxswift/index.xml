<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rxswift on chooblarin&#39;s blog</title>
    <link>http://chooblarin.github.io/tags/rxswift/index.xml</link>
    <description>Recent content in Rxswift on chooblarin&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 chooblarin</copyright>
    <atom:link href="http://chooblarin.github.io/tags/rxswift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>RxSwiftのSchedulersと戯れる</title>
      <link>http://chooblarin.github.io/post/understanding-schedulers/</link>
      <pubDate>Fri, 05 May 2017 13:36:25 +0900</pubDate>
      
      <guid>http://chooblarin.github.io/post/understanding-schedulers/</guid>
      <description>

&lt;p&gt;iOSのアプリ開発を始めて1年が経過しました．RxSwiftとの付き合いも1年が経過しました．最近は仕事で再びAndroidの担当になりました．&lt;/p&gt;

&lt;p&gt;この記事はRxSwiftとSchedulersについて書きました．GCDの話は出て来ませんので真剣に勉強した方には以下の解説がとても素晴らしいです．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mixi-inc/iOSTraining/wiki/8.2-Grand-Central-Dispatch&#34;&gt;8.2 Grand Central Dispatch · mixi-inc/iOSTraining Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;observableとスレッド&#34;&gt;Observableとスレッド&lt;/h2&gt;

&lt;p&gt;Swiftは3.1です．&lt;/p&gt;

&lt;p&gt;まず，RxSwiftでてきとうなObservableを作ります．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in
  observer.onNext(&amp;quot;YO!😎&amp;quot;)
  observer.onCompleted()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;observable.subscribe(onNext: { (message: String) in
  print(message)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に，5秒後に「YO!」を受け取るようにObservableを変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in
  Thread.sleep(forTimeInterval: 5) // Blocking
  observer.onNext(&amp;quot;YO!😎&amp;quot;)
  observer.onCompleted()
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observableの処理は，通常は&lt;code&gt;subscribe&lt;/code&gt;を呼び出したスレッドで実行されます．
なので&lt;code&gt;Thread.sleep&lt;/code&gt;はmainスレッドをブロックしています．mainスレッドをブロックするのはイケないことなので，明示的に別のスレッドで処理するように変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5) // ...zzZ

    observer.onNext(&amp;quot;YO!😎&amp;quot;)
    observer.onCompleted()
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「YO!」がどのスレッドから来ているのか知りたいのでヘルパー関数を作って&lt;code&gt;subscribe&lt;/code&gt;する側を少し変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func which() -&amp;gt; String {
  return Thread.isMainThread ? &amp;quot;main&amp;quot; : &amp;quot;background&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;observable.subscribe(onNext: { (message: String) in
  print(&amp;quot;\(message) on \(which())&amp;quot;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 on background
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バックグラウンドから「YO!」が届きました．&lt;/p&gt;

&lt;p&gt;mainスレッド以外からUIに触ろうとするとSystemに怒られてしまいます．なので別スレッドで眠ってから「YO!」の送信だけをmainスレッドで行うように変更します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5)

    DispatchQueue.main.async {
      observer.onNext(&amp;quot;YO!😎&amp;quot;)
      observer.onCompleted()
    }
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;YO!😎 on main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うまくいきました．これでノンブロッキングYO!YO!が可能になりました．&lt;/p&gt;

&lt;p&gt;さて，ここまでの「YO!」を振り返ってみます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  observer.onNext(&amp;quot;YO!😎&amp;quot;) // where subscribe() is called

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5)
    observer.onNext(&amp;quot;YO!😎&amp;quot;) // background

    DispatchQueue.main.async {
      observer.onNext(&amp;quot;YO!😎&amp;quot;) // main
      observer.onCompleted()
    }
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 on main
YO!😎 on background
YO!😎 on main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いい感じです．&lt;/p&gt;

&lt;h2 id=&#34;schedulers&#34;&gt;Schedulers&lt;/h2&gt;

&lt;p&gt;次はいよいよSchedulerを使います．Observableの&lt;code&gt;observeOn&lt;/code&gt;に&lt;code&gt;MainScheduler&lt;/code&gt;を指定します．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;observable
  .observeOn(MainScheduler.instance)
  .subscribe(onNext: { (message: String) in
    print(&amp;quot;\(message) (Here is \(which()))&amp;quot;)
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 (Here is main)
YO!😎 (Here is main)
YO!😎 (Here is main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;subscribe&lt;/code&gt;の中が全てmainスレッドで実行されるようになりました．&lt;code&gt;MainScheduler&lt;/code&gt;を指定したおかげで&lt;code&gt;DispatchQueue.main.async&lt;/code&gt;は不要になりました．&lt;/p&gt;

&lt;p&gt;「YO!」がどこから来ているのかわからなくなってしまったので少し変更を加えます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in

  observer.onNext(&amp;quot;YO!😎 from \(which()).&amp;quot;)

  DispatchQueue.global(qos: .default).async {

    Thread.sleep(forTimeInterval: 5)

    observer.onNext(&amp;quot;YO!😎 from \(which()).&amp;quot;)
    observer.onCompleted()
  }
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 from main. (Here is main)
YO!😎 from background. (Here is main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;observeOn&lt;/code&gt;の振る舞いがわかりました．&lt;/p&gt;

&lt;p&gt;次に，&lt;code&gt;subscribeOn&lt;/code&gt;でObservableの処理を実行するスレッドを指定します．先ほど述べた通り，Observableの処理は，通常は&lt;code&gt;subscribe&lt;/code&gt;を呼び出したスレッドで実行されます．
しかし&lt;code&gt;subscribeOn&lt;/code&gt;を使うとこれを変更することができます．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;observable
  .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .default))
  .observeOn(MainScheduler.instance)
  .subscribe(onNext: { (message: String) in
    print(&amp;quot;\(message) (Here is \(which()))&amp;quot;)
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;YO!😎 from background. (Here is main)
YO!😎 from background. (Here is main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スリープの処理をDispatchQueueで指定する必要が無くなりますので，Observableはこうなります．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = Observable&amp;lt;String&amp;gt;.create { observer -&amp;gt; Disposable in
  Thread.sleep(forTimeInterval: 5)
  observer.onNext(&amp;quot;YO!😎 from \(which()).&amp;quot;)
  observer.onCompleted()
  return Disposables.create()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは冒頭に出て来たObservableです．Schedulersを利用すれば簡単にノンブロッキングYO!YO!が出来ます．以上です．&lt;/p&gt;

&lt;p&gt;ソースコードは&lt;a href=&#34;https://gist.github.com/chooblarin/a041328422870581c616f32717d80393&#34;&gt;Gist&lt;/a&gt; に置いておきます．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md&#34;&gt;RxSwift/Schedulers.md at master · ReactiveX/RxSwift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftpearls.com/RxSwift-for-dummies-2-Operators.html&#34;&gt;RxSwift For Dummies 🐥 Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>