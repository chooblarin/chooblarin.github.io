{"pageProps":{"postContent":{"title":"JavaScriptで配列を正しくシャッフル","date":"2018-10-14T10:56:00+09:00","slug":"array-shuffle","tags":["JavaScript","algorithm"],"draft":false,"content":"<p>JavaScript の Array をシャッフルする方法について調べてみたら，ちょっとだけおもしろかったのでブログに書くことにしました．</p>\n<h2>Fisher–Yates アルゴリズム</h2>\n<p>まず最初に，偏りの少ない公平なシャッフルする正しい方法を説明します．<a href=\"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\">Fisher–Yates shuffle</a> というアルゴリズムです．（<a href=\"https://bost.ocks.org/mike/shuffle/\">こちら</a>に素晴らしい解説があります．）</p>\n<p>トランプの束があり，これをシャッフルしたいとしましょう．束の中からランダムに 1 枚ずつ選び，束の隣に新しい束（シャッフル済の束）として重ねていきます．これが Fisher–Yates シャッフルです．</p>\n<p><a href=\"https://30secondsofcode.org/\">30secondsofcode.org</a>では以下のような実装を紹介しています．</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shuffle</span> = (<span class=\"hljs-params\">[...arr]</span>) => {\n  <span class=\"hljs-keyword\">let</span> m = arr.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">while</span> (m) {\n    <span class=\"hljs-keyword\">const</span> i = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * m--);\n    [arr[m], arr[i]] = [arr[i], arr[m]];\n  }\n  <span class=\"hljs-keyword\">return</span> arr;\n};\n</code></pre>\n<p>https://github.com/30-seconds/30-seconds-of-code#shuffle</p>\n<p>ざっくりした手順は以下の通りです．</p>\n<ul>\n<li>長さが $N$ の配列がある．</li>\n<li>$[0, m-1]$ の区間からランダムな要素番号を取得し，$m$ 番目の要素と入れ替える．</li>\n<li>$m$ は $N$ からスタートし，1 つずつ減らしていき，0 になるまで繰り返す．</li>\n</ul>\n<p>$m$ は未シャッフルな要素の数であると考えるとわかりやすいです．ここでの 1 つのポイントは，$[0, m-1]$ の区間に含まれる要素の数と $m$ との和が常に \b $N$ であるという点です．</p>\n<p>上述したトランプの束の例では，「未シャッフルの束」の「シャッフル済の束」の 2 つが登場しました．もしもそれぞれを別の配列として扱うとしたらどうなるでしょう．\n以下のコードは，トランプの例を愚直にシミュレートした非効率な実装です．</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 非効率なバージョン</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">insufficientShuffle</span> = (<span class=\"hljs-params\">[...arr]</span>) => {\n  <span class=\"hljs-keyword\">const</span> copy = [];\n  <span class=\"hljs-keyword\">let</span> m = arr.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">while</span> (m) {\n    <span class=\"hljs-keyword\">const</span> i = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * m--);\n    copy.<span class=\"hljs-title function_\">push</span>(arr.<span class=\"hljs-title function_\">splice</span>(i, <span class=\"hljs-number\">1</span>)[<span class=\"hljs-number\">0</span>]);\n  }\n  <span class=\"hljs-keyword\">return</span> copy;\n};\n</code></pre>\n<p>上のコードは正しく動作しますが，<code>splice()</code> がイテレーションごとに要素をシフトするため効率が悪いです．\n先ほどの実装は「$[0, m-1]$ の区間に含まれる要素の数と $m$ との和が常に \b $N$ である」という事実により，1 つの配列の要素をスワップするだけのシンプルな実装になっていて計算効率も良いです．</p>\n<h2>偏りが出てしまう不公平なシャッフル</h2>\n<p>Fisher–Yates shuffle が良いアルゴリズムであることは分かりましたが，偏りが生じてしまう実装は何が悪いのでしょうか．</p>\n<p>実は，「JavaScript 配列 シャッフル」でググって最初に見つけたコード（良くない実装）は以下です．</p>\n<pre><code class=\"hljs language-js\">array.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() - <span class=\"hljs-number\">0.5</span>);\n</code></pre>\n<p>このシャッフルの問題点は<a href=\"https://www.robweir.com/blog/2010/02/microsoft-random-browser-ballot.html\">こちら</a>の記事が指摘しています．実験してみるとかなり大きな偏りが確認できます．</p>\n<h3>混ぜすぎ注意...？</h3>\n<p>Fisher–Yates shuffle では要素を入れ替えるランダムの位置を $[0, m-1]$ から選んでいました．これを$[0, N-1]$から選ぶようにするとどうなるでしょうか．\nつまり，ランダムに入れ替える範囲を常に配列の全ての要素にします．実装は以下の通りです （\bNaïve shuffle と呼ぶそうです）．</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">naiveShuffle</span> = (<span class=\"hljs-params\">[...arr]</span>) => {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> m = arr.<span class=\"hljs-property\">length</span>; m > <span class=\"hljs-number\">0</span>; m--) {\n    <span class=\"hljs-keyword\">const</span> i = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * arr.<span class=\"hljs-property\">length</span>);\n    [arr[m], arr[i]] = [arr[i], arr[m]];\n  }\n};\n</code></pre>\n<p>実は，この実装方法ではシャッフルの結果に無視できないほどの偏りが生じます．なぜ偏ってしまうのかについて興味がある方は~~疲れたので~~<a href=\"https://blog.codinghorror.com/the-danger-of-naivete/\">こちら</a>の記事をご覧下さい．</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\">\"Fisher–Yates shuffle - Wikipedia\"</a></li>\n<li><a href=\"https://bost.ocks.org/mike/shuffle/\">\"Fisher–Yates Shuffle\"</a></li>\n<li><a href=\"https://blog.codinghorror.com/the-danger-of-naivete/\">\"The Danger of Naïveté\"</a></li>\n<li><a href=\"https://www.robweir.com/blog/2010/02/microsoft-random-browser-ballot.html\">\"Doing the Microsoft Shuffle: Algorithm Fail in Browser Ballot\"</a></li>\n<li><a href=\"https://30secondsofcode.org/\">\"Array - 30 seconds of code\"</a></li>\n</ul>"}},"__N_SSG":true}