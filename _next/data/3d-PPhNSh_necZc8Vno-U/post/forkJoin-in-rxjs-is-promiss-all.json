{"pageProps":{"postContent":{"title":"RxJSのforkJoinはPromise.all相当","date":"2018-10-11T02:08:00+09:00","slug":"forkJoin-in-rxjs-is-promiss-all","tags":["RxJS"],"draft":false,"content":"<p>以前（ずいぶんと前だけど）に，<a href=\"https://chooblarin.github.io/post/20160529/\">RxJavaについてのエントリ</a>で，「RxJavaに <code>Promise.all()</code>が欲しい」という話をしました．この時に紹介したRxJavaの<code>concatMapEager</code>は，当時はExperimentalでしたが現在はStableになっています．</p>\n<hr>\n<p>今回はRxJavaではなくRxJSについてです．</p>\n<p>先のエントリの中で，私が求めいたのは</p>\n<ol>\n<li>処理が並行して実行される</li>\n<li>順番が保存されている</li>\n</ol>\n<p>という特徴を持ったオペレータでした．そして最近，RxJSの<code>forkJoin</code>を知りました．</p>\n<h2>RxJSのforkJoin</h2>\n<p>RxJSに<code>forkJoin</code>というAPIがあります．これはObservableのリストを受け取り，それらが最後にemitした値のリストのObservableをつくります．</p>\n<p>例えば</p>\n<pre><code><span>forkJoin</span>(\n  <span>of</span>(<span>'君がッ'</span>, <span>'泣くまで'</span>),\n  <span>of</span>(<span>'殴るのを'</span>, <span>'やめないッ！'</span>),\n).<span>subscribe</span>(<span>console</span>.<span>log</span>); <span>// [\"泣くまで\", \"やめないッ！\"]</span></code></pre>\n<p>という具合です．<code>forkJoin(...)</code>は<code>Promise.all(...)</code>のObservable版なのです．</p>\n<p>次に，こんなモノを用意しました．</p>\n<pre><code><span>const</span> <span>rand</span> = (<span></span>) => <span>Math</span>.<span>floor</span>(<span>Math</span>.<span>random</span>() * <span>3</span>) * <span>1000</span>;\n<span>const</span> <span>delayedEcho</span> = (<span>message</span>) => <span>of</span>(message).<span>pipe</span>(<span>delay</span>(<span>rand</span>()));</code></pre>\n<p>ランダム時間後にメッセージをそのまま返してくれる，その名も<code>delayedEcho</code>です．</p>\n<pre><code><span>const</span> ids = [<span>'1'</span>, <span>'2'</span>, <span>'3'</span>, <span>'4'</span>, <span>'5'</span>];\n<span>const</span> observables = ids.<span>map</span>(delayedEcho);\n<span>forkJoin</span>(observables).<span>subscribe</span>(<span>console</span>.<span>log</span>);\n<span>// [\"1\", \"2\", \"3\", \"4\", \"5\"]</span></code></pre>\n<p>はい，完全に思い通りに動いてくれました．</p>\n<h2>xxxMapなオペレータ達</h2>\n<p>ここから先はおまけです．先ほどの<code>delayedEcho</code>で遊んでみます．</p>\n<h3>mergeMap</h3>\n<pre><code><span>from</span>(ids)\n  .<span>pipe</span>(\n    <span>mergeMap</span>(delayedEcho),\n    <span>toArray</span>()\n  )\n  .<span>subscribe</span>(<span>console</span>.<span>log</span>);\n\n<span>// [\"3\", \"5\", \"1\", \"2\", \"4\"]</span></code></pre>\n<p><code>mergeMap</code>は<code>flatMap</code>です (<code>flatMap</code>が<code>mergeMap</code>のエイリアス)．処理は並行に走りますが，購読される値は先着順です．</p>\n<h3>concatMap</h3>\n<pre><code><span>from</span>(ids)\n  .<span>pipe</span>(\n    <span>concatMap</span>(delayedEcho),\n    <span>toArray</span>()\n  )\n  .<span>subscribe</span>(<span>console</span>.<span>log</span>);\n\n<span>// [\"1\", \"2\", \"3\", \"4\", \"5\"]</span></code></pre>\n<p><code>concatMap</code>は，処理が直列です．現在の処理が完了するまで次の処理を開始しません．したがって，上記の例は<code>mergeMap</code>の平均およそ5倍の時間が掛かります．</p>\n<h3>switchMap</h3>\n<pre><code><span>from</span>(ids)\n  .<span>pipe</span>(\n    <span>switchMap</span>(delayedEcho),\n    <span>toArray</span>()\n  )\n  .<span>subscribe</span>(<span>console</span>.<span>log</span>);\n\n<span>// [\"5\"]</span></code></pre>\n<p><code>switchMap</code>は最新のObservableに関心を切り替えます．</p>\n<p>ここで，<code>delayedEcho</code>に少し小細工をします．</p>\n<pre><code><span>const</span> <span>delayedEcho</span> = (<span>message</span>) => <span>of</span>(message)\n  .<span>pipe</span>(\n    <span>tap</span>(<span>console</span>.<span>log</span>), <span>// &#x3C;= これを追加</span>\n    <span>delay</span>(<span>rand</span>())\n  );</code></pre>\n<p>そして先ほどの<code>switchMap</code>のコードをもう一度実行すると...</p>\n<pre><code><span>from</span>(ids)\n  .<span>pipe</span>(\n    <span>switchMap</span>(delayedEcho),\n    <span>toArray</span>()\n  )\n  .<span>subscribe</span>(<span>console</span>.<span>log</span>);\n\n<span>// \"1\"</span>\n<span>// \"2\"</span>\n<span>// \"3\"</span>\n<span>// \"4\"</span>\n<span>// \"5\"</span>\n<span>// [\"5\"]</span></code></pre>\n<p><code>\"1\"</code>から<code>\"4\"</code>は無視されたかと思いきや，全てのObservableの処理は実行を開始していたことがわかります．</p>\n<h3>exhaustMap</h3>\n<p>最後が<code>exhaustMap</code>です．このオペレータは重要です．</p>\n<pre><code><span>from</span>(ids)\n  .<span>pipe</span>(\n    <span>exhaustMap</span>(delayedEcho),\n    <span>toArray</span>()\n  )\n  .<span>subscribe</span>(<span>console</span>.<span>log</span>);\n\n<span>// \"1\"</span>\n<span>// [\"1\"]</span></code></pre>\n<p><code>exhaustMap</code>は，前の処理が完了していなかい場合には後続の処理を無視します．この挙動は，非同期処理が不整合を起こさないための様々なケースに使えます．</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/api\">RxJS - API List</a></li>\n</ul>\n"}},"__N_SSG":true}