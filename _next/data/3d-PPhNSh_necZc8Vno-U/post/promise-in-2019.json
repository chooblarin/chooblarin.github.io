{"pageProps":{"postContent":{"title":"2019年のPromise","date":"2019-12-01T00:00:00+00:00","slug":"promise-in-2019","tags":["JavaScript"],"draft":false,"content":"<p>この記事は<a href=\"https://adventar.org/calendars/4155\">フラー Advent Calendar 2019</a>の 1 日目の記事です。</p>\n<p>今年も JavaScript (TypeSctipt) をたくさん書きました。</p>\n<p>JavaScript には ECMAScript という標準仕様がありますが，近年では TC39 によって毎年新しい機能が追加されています。議論のプロセスは常にオープンになっているので誰でも閲覧できます <a href=\"https://github.com/tc39\">*</a>。</p>\n<p>そして今回は JavaScript の\"Promise\"にフォーカスして近況を解説します。</p>\n<h2>Promise で非同期プログラミング</h2>\n<p>Promise は ES2015 (ES6)で正式に導入されましたが，それ以前にも JavaScript プログラミングの非同期処理の中心にいました。</p>\n<p>まずは Promise について簡単に復習しましょう。コンストラクタで Promise を生成する一般的な形式の例を以下に示します。</p>\n<pre><code><span>const</span> promise = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>doSomething</span>(<span><span>x</span> =></span> {\n    <span>if</span> (x) {\n      <span>// 成功</span>\n      <span>resolve</span>(x);\n    } <span>else</span> {\n      <span>reject</span>(<span>new</span> <span>Error</span>(<span>\"失敗😢\"</span>));\n    }\n  });\n});\n\n\npromise\n  .<span>then</span>(<span><span>result</span> =></span> { ... })\n  .<span>catch</span>(<span><span>error</span> =></span> { ... });</code></pre>\n<p><code>doSomething</code> は何らかの非同期処理を行い，コールバックによって結果を得る関数です。無事に結果が得られたときは <code>resolve()</code> を使います。もしも結果が得られなかったときは <code>reject()</code>を使います。</p>\n<p>Promise には\"pending\", \"fulfilled\", \"rejected\" の 3 つの状態が存在します。先ほどの例で，<code>resolve()</code> か <code>reject()</code> を呼びだす前の状態は <strong>pending</strong> 状態です。呼び出したあとは <strong>fulfilled</strong> か <strong>rejected</strong> のいずれかの状態になります（これを <strong>Settled</strong> と呼びます）。</p>\n<p>Promise は必ず 3 つのうちいずれか状態をとりますが，Settled にならない場合もあります。例えば，以下の Promise は永久に pending 状態です。</p>\n<pre><code><span>const</span> p = <span>new</span> <span>Promise</span>(<span>() =></span> {});</code></pre>\n<h2><code>.finally()</code></h2>\n<p>ES2018 では <code>Promise.prototype.finally()</code> が導入されています。</p>\n<pre><code>promise\n  .<span>then</span>(<span><span>result</span> =></span> { ... })\n  .<span>catch</span>(<span><span>error</span> =></span> { ... })\n  .<span>finally</span>(<span>() =></span> {\n    <span>// 後始末をここに書く</span>\n  });</code></pre>\n<p><code>.finally()</code>のコールバック関数は，fulfilled か rejected かに関わらず実行されます。</p>\n<h2>複数の Promise を操る <code>Promise.all</code> と <code>Promise.race</code></h2>\n<p>ES2015 では， 複数の Promise を操作する API <code>Promise.all</code> と <code>Promise.race</code> の 2 つが導入されました。</p>\n<ul>\n<li><code>Promise.all</code>：全ての Promise が fulfilled となった結果</li>\n<li><code>Promise.race</code>：いずれかの Promise のうち最初に Settled となった結果</li>\n</ul>\n<p><code>Promise.all</code> は複数の非同期処理を同時にスタートして，全てが完了したその結果を扱いたいときに使います。</p>\n<pre><code><span>const</span> p1 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(<span>\"成功😄\"</span>), <span>100</span>);\n});\n\n<span>const</span> p2 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(<span>\"成功😁\"</span>), <span>200</span>);\n});\n\n<span>const</span> p3 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(<span>\"成功😎\"</span>), <span>300</span>);\n});\n\n<span>Promise</span>.<span>all</span>([p1, p2, p3])\n  .<span>then</span>(<span><span>result</span> =></span> <span>console</span>.<span>log</span>(result)) <span>// [\"成功😄\", \"成功😁\", \"成功😎\"]</span>\n  .<span>catch</span>(<span><span>e</span> =></span> <span>console</span>.<span>log</span>(e.<span>message</span>));</code></pre>\n<h2><code>Promise.allSettled</code> と <code>Promise.any</code></h2>\n<p><code>Promise.all</code> は，Promise が 1 つでも失敗して <code>rejected</code> になったら，その結果は <code>rejected</code> になってしまいます。</p>\n<pre><code><span>const</span> p1 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(<span>\"成功😄\"</span>), <span>100</span>);\n});\n\n<span>const</span> p2 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(<span>\"成功😁\"</span>), <span>200</span>);\n});\n\n<span>const</span> p3 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>reject</span>(<span>new</span> <span>Error</span>(<span>\"失敗😭\"</span>)), <span>300</span>);\n});\n\n<span>Promise</span>.<span>all</span>([p1, p2, p3])\n  .<span>then</span>(<span><span>result</span> =></span> <span>console</span>.<span>log</span>(result))\n  .<span>catch</span>(<span><span>e</span> =></span> <span>console</span>.<span>log</span>(e.<span>message</span>)); <span>// \"失敗😭\"</span></code></pre>\n<p>そこで新たに 2 つの API が提案され，導入されようとしています。</p>\n<ul>\n<li><code>Promise.allSettled</code>：全ての Promise が Settled となった結果</li>\n<li><code>Promise.any</code>：いずれかの Promise が最初に fulfilled となった結果。全ての Promise が rejected の場合にのみ，rejected 状態になる。</li>\n</ul>\n<p>先ほどの例を <code>Promise.allSettled</code> を使って書くと以下のようになります。</p>\n<pre><code><span>const</span> p1 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(<span>\"成功😄\"</span>), <span>100</span>);\n});\n\n<span>const</span> p2 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(<span>\"成功😁\"</span>), <span>200</span>);\n});\n\n<span>const</span> p3 = <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =></span> {\n  <span>setTimeout</span>(<span>() =></span> <span>reject</span>(<span>new</span> <span>Error</span>(<span>\"失敗😭\"</span>)), <span>300</span>);\n});\n\n<span>Promise</span>.<span>allSettled</span>([p1, p2, p3])\n  .<span>then</span>(<span><span>result</span> =></span> <span>console</span>.<span>log</span>(result.<span>map</span>(<span><span>r</span> =></span> r.<span>value</span>))) <span>// [\"成功😄\", \"成功😁\", undefined]</span>\n  .<span>catch</span>(<span><span>e</span> =></span> <span>console</span>.<span>log</span>(e.<span>message</span>));</code></pre>\n<h2><code>async</code> / <code>await</code></h2>\n<p>ES2017 で追加された Async 関数を使うと，Promise を更に扱いやすくなります。Async 関数は以下のように <code>async</code> キーワードがついた関数です。</p>\n<pre><code><span>async</span> <span>function</span> <span>makePizza</span>(<span></span>) {\n  <span>const</span> ingredients = <span>await</span> <span>prepareIngredients</span>(); <span>// 材料を用意します</span>\n  <span>const</span> pizza = <span>await</span> <span>bakePizza</span>(); <span>// ピザを焼きます</span>\n  <span>return</span> pizza;\n}</code></pre>\n<p>Async 関数の中では，<code>await</code> オペレータを使用できます。 <code>await</code> は Promise が Settled になるまで待機し，結果が得られたら処理を再開します。もしもその Promise が fulfilled となった場合，<code>await</code> はその値を返します。もしも rejected となった場合はそのエラーを throw します（try-catch 構文でハンドリングできます）。</p>\n<p>Async 関数の結果は常に Promise です。したがって以下の 2 つの Async 関数は同じ値（\"🍕\"の Promise）を返します。</p>\n<pre><code><span>async</span> <span>function</span> <span>makePizza1</span>(<span></span>) {\n  <span>return</span> <span>\"🍕\"</span>;\n}\n\n<span>async</span> <span>function</span> <span>makePizza2</span>(<span></span>) {\n  <span>return</span> <span>Promise</span>.<span>resolve</span>(<span>\"🍕\"</span>);\n}\n\n<span>const</span> pizza1 = <span>await</span> <span>makePizza1</span>();\n<span>const</span> pizza2 = <span>await</span> <span>makePizza2</span>();\n<span>console</span>.<span>log</span>(pizza1 === pizza2); <span>// true</span></code></pre>\n<p><code>await</code> は Promise ではない値も受け付けます。</p>\n<pre><code><span>const</span> burger1 = <span>await</span> <span>\"🍔\"</span>;\n<span>const</span> burger2 = <span>await</span> <span>Promise</span>.<span>resolve</span>(<span>\"🍔\"</span>);\n<span>console</span>.<span>log</span>(burger1 === burger2); <span>// true</span></code></pre>\n<h3>コールバック関数と <code>await</code></h3>\n<p>まず最初に以下のヘルパー関数を定義します。</p>\n<pre><code><span>async</span> <span>function</span> <span>delayEcho</span>(<span>x, ms</span>) {\n  <span>return</span> <span>new</span> <span>Promise</span>(<span><span>resolve</span> =></span>\n    <span>setTimeout</span>(<span>() =></span> {\n      <span>resolve</span>(x);\n    }, ms)\n  );\n}</code></pre>\n<p>引数 <code>x</code> で指定した値を引数<code>ms</code> で指定した分だけ待って resolve する Async 関数です。</p>\n<p><code>[\"🍔\", \"🍕\", \"🍣\"]</code>という配列をこの関数と<code>.map()</code> で処理したいとき，以下のように書きたくなるかもしれませんが，<code>.map()</code> に渡している関数に <code>async</code> キーワードが無いためシンタックスエラーです。</p>\n<pre><code><span>async</span> <span>function</span> <span>delayedFoods</span>(<span></span>) {\n  <span>const</span> foods = [<span>\"🍔\"</span>, <span>\"🍕\"</span>, <span>\"🍣\"</span>];\n  <span>return</span> foods.<span>map</span>(<span><span>f</span> =></span> <span>await</span> <span>delayEcho</span>(f, <span>100</span>)); <span>// シンタックスエラー 🙅‍♀️</span>\n}\n\n<span>const</span> x = <span>await</span> <span>delayedFoods</span>();\n<span>console</span>.<span>log</span>(x);</code></pre>\n<p>コードバック関数にも <code>async</code> キーワードをつけるとシンタックスエラーは無くなりますが，先に述べたとおり Async 関数の返り値は Promise なので，正しく動作するには，<code>Promise.all</code> を使って以下のように書きます。</p>\n<pre><code><span>async</span> <span>function</span> <span>delayedFoods</span>(<span></span>) {\n  <span>const</span> foods = [<span>\"🍔\"</span>, <span>\"🍕\"</span>, <span>\"🍣\"</span>];\n  <span>return</span> <span>Promise</span>.<span>all</span>(foods.<span>map</span>(<span>async</span> f => <span>await</span> <span>delayEcho</span>(f, <span>100</span>)));\n}\n\n<span>const</span> x = <span>await</span> <span>delayedFoods</span>();\n<span>console</span>.<span>log</span>(x); <span>// [\"🍔\", \"🍕\", \"🍣\"]</span></code></pre>\n<p>実はこの例は， <code>delayEcho</code> の結果を <code>await</code> する必要はなく以下のように書くとよりシンプルです。</p>\n<pre><code><span>async</span> <span>function</span> <span>delayedFoods</span>(<span></span>) {\n  <span>const</span> foods = [<span>\"🍔\"</span>, <span>\"🍕\"</span>, <span>\"🍣\"</span>];\n  <span>return</span> <span>Promise</span>.<span>all</span>(foods.<span>map</span>(<span><span>f</span> =></span> <span>delayEcho</span>(f, <span>100</span>)));\n}</code></pre>\n<h2>Async イテレーション</h2>\n<p>最後に，ES2018 で追加された Async イテレーションをみていきます。</p>\n<pre><code><span>async</span> <span>function</span>* <span>collectFoods</span>(<span></span>) {\n  <span>await</span> <span>new</span> <span>Promise</span>(<span><span>resolve</span> =></span> <span>setTimeout</span>(<span>() =></span> <span>resolve</span>(), <span>1000</span>));\n  <span>yield</span> <span>delayEcho</span>(<span>\"🌭\"</span>, <span>100</span>);\n  <span>yield</span> <span>delayEcho</span>(<span>\"🍜\"</span>, <span>100</span>);\n  <span>yield</span> <span>\"🍖\"</span>;\n}</code></pre>\n<p><code>collectFoods</code> は Async ジェネレータ関数です。<code>await</code> に加えて <code>yield</code> を使うことができます。<code>collectFoods</code>は Async iterator を作成します。Async iterator は <code>.next()</code> を呼び出すと結果が Promise で返ってきます。</p>\n<pre><code><span>const</span> asyncIter = <span>collectFoods</span>();\n<span>console</span>.<span>log</span>(<span>await</span> asyncIter.<span>next</span>()); <span>// {value: \"🌭\", done: false}</span>\n<span>console</span>.<span>log</span>(<span>await</span> asyncIter.<span>next</span>()); <span>// {value: \"🍜\", done: false}</span>\n<span>console</span>.<span>log</span>(<span>await</span> asyncIter.<span>next</span>()); <span>// {value: \"🍖\", done: false}</span>\n<span>console</span>.<span>log</span>(<span>await</span> asyncIter.<span>next</span>()); <span>// {value: undefined, done: true}</span></code></pre>\n<p>さらに，Async Iterator のループは <code>for await...of</code> 構文を使うことができます。</p>\n<pre><code><span>for</span> <span>await</span> (<span>const</span> food <span>of</span> <span>collectFoods</span>()) {\n  <span>console</span>.<span>log</span>(food);\n  <span>// \"🌭\"</span>\n  <span>// \"🍜\"</span>\n  <span>// \"🍖\"</span>\n}</code></pre>\n<p>ちなみに <code>for await...of</code> 構文は Async では無い通常の iterator でも正常に動作します。</p>\n<pre><code><span>for</span> <span>await</span> (<span>const</span> food <span>of</span> [<span>'🍎'</span>, <span>'🍊'</span>, <span>Promise</span>.<span>resolve</span>(<span>'🍋'</span>)]) {\n  <span>console</span>.<span>log</span>(food);\n  <span>// 🍎</span>\n  <span>// 🍊</span>\n  <span>// 🍋</span>\n}</code></pre>\n<h2>おわりに</h2>\n<p>今年は，僭越ながら周囲の人に JavaScript を教える機会をいただくことが多い 1 年でした。特に Promise について質問されることが多かったので，この記事を書こうと思いつきました。来年も元気にやっていきますのでよろしくお願いします 👋</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://exploringjs.com/es2018-es2019/\">Exploring ES2018 and ES2019</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\">Promise.allSettled() - JavaScript | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\">Promise.any() - JavaScript | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\">for await...of - JavaScript | MDN</a></li>\n<li><a href=\"https://github.com/tc39/proposal-promise-any\">tc39/proposal-promise-any: ECMAScript proposal: Promise.any</a></li>\n<li><a href=\"https://github.com/tc39/proposal-async-iteration\">tc39/proposal-async-iteration: Asynchronous iteration for JavaScript</a></li>\n<li><a href=\"https://v8.dev/features/promise-combinators\">Promise combinators · V8</a></li>\n</ul>\n"}},"__N_SSG":true}