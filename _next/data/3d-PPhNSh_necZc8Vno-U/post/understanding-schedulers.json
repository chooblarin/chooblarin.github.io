{"pageProps":{"postContent":{"title":"RxSwiftのSchedulersと戯れる","date":"2017-05-05T13:36:25+09:00","slug":"understanding-schedulers","tags":["Swift","RxSwift"],"draft":false,"content":"<p>iOS のアプリ開発を始めて 1 年が経過しました．RxSwift との付き合いも 1 年が経過しました．最近は仕事で再び Android の担当になりました．</p>\n<p>この記事は RxSwift と Schedulers について書きました．GCD の話は出て来ませんので真剣に勉強した方には以下の解説がとても素晴らしいです．</p>\n<ul>\n<li><a href=\"https://github.com/mixi-inc/iOSTraining/wiki/8.2-Grand-Central-Dispatch\">8.2 Grand Central Dispatch · mixi-inc/iOSTraining Wiki</a></li>\n</ul>\n<hr>\n<h2>Observable とスレッド</h2>\n<p>Swift は 3.1 です．</p>\n<p>まず，RxSwift でてきとうな Observable を作ります．</p>\n<pre><code><span>let</span> observable <span>=</span> <span>Observable</span>&#x3C;<span>String</span>>.create { observer -> <span>Disposable</span> <span>in</span>\n  observer.onNext(<span>\"YO!😎\"</span>)\n  observer.onCompleted()\n}</code></pre>\n<pre><code>observable.subscribe(onNext: { (message: <span>String</span>) <span>in</span>\n  <span>print</span>(message)\n})</code></pre>\n<pre><code>YO!😎</code></pre>\n<p>次に，5 秒後に「YO!」を受け取るように Observable を変更します．</p>\n<pre><code><span>let</span> observable <span>=</span> <span>Observable</span>&#x3C;<span>String</span>>.create { observer -> <span>Disposable</span> <span>in</span>\n  <span>Thread</span>.sleep(forTimeInterval: <span>5</span>) <span>// Blocking</span>\n  observer.onNext(<span>\"YO!😎\"</span>)\n  observer.onCompleted()\n  <span>return</span> <span>Disposables</span>.create()\n}</code></pre>\n<p>Observable の処理は，通常は<code>subscribe</code>を呼び出したスレッドで実行されます．\nなので<code>Thread.sleep</code>は main スレッドをブロックしています．main スレッドをブロックするのはイケないことなので，明示的に別のスレッドで処理するように変更します．</p>\n<pre><code><span>let</span> observable <span>=</span> <span>Observable</span>&#x3C;<span>String</span>>.create { observer -> <span>Disposable</span> <span>in</span>\n\n  <span>DispatchQueue</span>.global(qos: .default).async {\n\n    <span>Thread</span>.sleep(forTimeInterval: <span>5</span>) <span>// ...zzZ</span>\n\n    observer.onNext(<span>\"YO!😎\"</span>)\n    observer.onCompleted()\n  }\n  <span>return</span> <span>Disposables</span>.create()\n}</code></pre>\n<p>「YO!」がどのスレッドから来ているのか知りたいのでヘルパー関数を作って<code>subscribe</code>する側を少し変更します．</p>\n<pre><code><span>func</span> <span>which</span>() -> <span>String</span> {\n  <span>return</span> <span>Thread</span>.isMainThread <span>?</span> <span>\"main\"</span> : <span>\"background\"</span>\n}</code></pre>\n<pre><code>observable.subscribe(onNext: { (message: <span>String</span>) <span>in</span>\n  <span>print</span>(<span>\"<span>\\(message)</span> on <span>\\(which())</span>\"</span>)\n})</code></pre>\n<pre><code>YO!😎 on background</code></pre>\n<p>バックグラウンドから「YO!」が届きました．</p>\n<p>main スレッド以外から UI に触ろうとすると System に怒られてしまいます．なので別スレッドで眠ってから「YO!」の送信だけを main スレッドで行うように変更します．</p>\n<pre><code><span>let</span> observable <span>=</span> <span>Observable</span>&#x3C;<span>String</span>>.create { observer -> <span>Disposable</span> <span>in</span>\n\n  <span>DispatchQueue</span>.global(qos: .default).async {\n\n    <span>Thread</span>.sleep(forTimeInterval: <span>5</span>)\n\n    <span>DispatchQueue</span>.main.async {\n      observer.onNext(<span>\"YO!😎\"</span>)\n      observer.onCompleted()\n    }\n  }\n  <span>return</span> <span>Disposables</span>.create()\n}</code></pre>\n<pre><code>YO!😎 on main</code></pre>\n<p>うまくいきました．これでノンブロッキング YO!YO!が可能になりました．</p>\n<p>さて，ここまでの「YO!」を振り返ってみます．</p>\n<pre><code><span>let</span> observable <span>=</span> <span>Observable</span>&#x3C;<span>String</span>>.create { observer -> <span>Disposable</span> <span>in</span>\n\n  observer.onNext(<span>\"YO!😎\"</span>) <span>// where subscribe() is called</span>\n\n  <span>DispatchQueue</span>.global(qos: .default).async {\n\n    <span>Thread</span>.sleep(forTimeInterval: <span>5</span>)\n    observer.onNext(<span>\"YO!😎\"</span>) <span>// background</span>\n\n    <span>DispatchQueue</span>.main.async {\n      observer.onNext(<span>\"YO!😎\"</span>) <span>// main</span>\n      observer.onCompleted()\n    }\n  }\n  <span>return</span> <span>Disposables</span>.create()\n}</code></pre>\n<pre><code>YO!😎 on main\nYO!😎 on background\nYO!😎 on main</code></pre>\n<p>いい感じです．</p>\n<h2>Schedulers</h2>\n<p>次はいよいよ Scheduler を使います．Observable の<code>observeOn</code>に<code>MainScheduler</code>を指定します．</p>\n<pre><code>observable\n  .observeOn(<span>MainScheduler</span>.instance)\n  .subscribe(onNext: { (message: <span>String</span>) <span>in</span>\n    <span>print</span>(<span>\"<span>\\(message)</span> (Here is <span>\\(which())</span>)\"</span>)\n  })</code></pre>\n<pre><code>YO!😎 (Here is main)\nYO!😎 (Here is main)\nYO!😎 (Here is main)</code></pre>\n<p><code>subscribe</code>の中が全て main スレッドで実行されるようになりました．<code>MainScheduler</code>を指定したおかげで<code>DispatchQueue.main.async</code>は不要になりました．</p>\n<p>「YO!」がどこから来ているのかわからなくなってしまったので少し変更を加えます．</p>\n<pre><code><span>let</span> observable <span>=</span> <span>Observable</span>&#x3C;<span>String</span>>.create { observer -> <span>Disposable</span> <span>in</span>\n\n  observer.onNext(<span>\"YO!😎 from <span>\\(which())</span>.\"</span>)\n\n  <span>DispatchQueue</span>.global(qos: .default).async {\n\n    <span>Thread</span>.sleep(forTimeInterval: <span>5</span>)\n\n    observer.onNext(<span>\"YO!😎 from <span>\\(which())</span>.\"</span>)\n    observer.onCompleted()\n  }\n  <span>return</span> <span>Disposables</span>.create()\n}</code></pre>\n<pre><code>YO!😎 from main. (Here is main)\nYO!😎 from background. (Here is main)</code></pre>\n<p><code>observeOn</code>の振る舞いがわかりました．</p>\n<p>次に，<code>subscribeOn</code>で Observable の処理を実行するスレッドを指定します．先ほど述べた通り，Observable の処理は，通常は<code>subscribe</code>を呼び出したスレッドで実行されます．\nしかし<code>subscribeOn</code>を使うとこれを変更することができます．</p>\n<pre><code>observable\n  .subscribeOn(<span>ConcurrentDispatchQueueScheduler</span>(qos: .default))\n  .observeOn(<span>MainScheduler</span>.instance)\n  .subscribe(onNext: { (message: <span>String</span>) <span>in</span>\n    <span>print</span>(<span>\"<span>\\(message)</span> (Here is <span>\\(which())</span>)\"</span>)\n  })</code></pre>\n<pre><code>YO!😎 from background. (Here is main)\nYO!😎 from background. (Here is main)</code></pre>\n<p>スリープの処理を DispatchQueue で指定する必要が無くなりますので，Observable はこうなります．</p>\n<pre><code><span>let</span> observable <span>=</span> <span>Observable</span>&#x3C;<span>String</span>>.create { observer -> <span>Disposable</span> <span>in</span>\n  <span>Thread</span>.sleep(forTimeInterval: <span>5</span>)\n  observer.onNext(<span>\"YO!😎 from <span>\\(which())</span>.\"</span>)\n  observer.onCompleted()\n  <span>return</span> <span>Disposables</span>.create()\n}</code></pre>\n<p>これは冒頭に出て来た Observable です．Schedulers を利用すれば簡単にノンブロッキング YO!YO!が出来ます．以上です．</p>\n<p>ソースコードは<a href=\"https://gist.github.com/chooblarin/a041328422870581c616f32717d80393\">Gist</a> に置いておきます．</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md\">RxSwift/Schedulers.md at master · ReactiveX/RxSwift</a></li>\n<li><a href=\"https://swiftpearls.com/RxSwift-for-dummies-2-Operators.html\">RxSwift For Dummies 🐥 Part 2</a></li>\n</ul>\n"}},"__N_SSG":true}