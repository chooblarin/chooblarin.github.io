{"pageProps":{"postContent":{"title":"ES2019を振り返る","date":"2019-11-27T22:32:00+09:00","slug":"looking-back-at-es2019","tags":["JavaScript"],"draft":false,"content":"<p>今年も残すところあと一ヶ月となりましたね。この記事では ES2019 の新機能をユースケースと共に振り返ってみます。</p>\n<h3><code>Array.prototype.flat</code></h3>\n<p><code>Array.prototype.flat()</code> は入れ子になった配列の要素を再帰的に辿って結合した配列を新たにつくります。引数には，何階層まで辿るか（depth）指定します。デフォルトは depth = 1 です。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-keyword\">const</span> array = [<span class=\"hljs-string\">\"零\"</span>, [<span class=\"hljs-string\">\"壱\"</span>], [[<span class=\"hljs-string\">\"弐\"</span>], [[<span class=\"hljs-string\">\"参\"</span>]]]];\n> array.flat()\n[<span class=\"hljs-string\">\"零\"</span>, <span class=\"hljs-string\">\"壱\"</span>, [<span class=\"hljs-string\">\"弐\"</span>], [[<span class=\"hljs-string\">\"参\"</span>]]]\n\n> array.flat(<span class=\"hljs-number\">2</span>)\n[<span class=\"hljs-string\">\"零\"</span>, <span class=\"hljs-string\">\"壱\"</span>, <span class=\"hljs-string\">\"弐\"</span>, [<span class=\"hljs-string\">\"参\"</span>]]\n\n> array.flat(<span class=\"hljs-number\">3</span>)\n[<span class=\"hljs-string\">\"零\"</span>, <span class=\"hljs-string\">\"壱\"</span>, <span class=\"hljs-string\">\"弐\"</span>, <span class=\"hljs-string\">\"参\"</span>]\n\n> array.flat(<span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">// 多めにdepthを指定</span>\n[<span class=\"hljs-string\">\"零\"</span>, <span class=\"hljs-string\">\"壱\"</span>, <span class=\"hljs-string\">\"弐\"</span>, <span class=\"hljs-string\">\"参\"</span>]\n\n> array.flat(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// depth = 0 は何も変更しない</span>\n[<span class=\"hljs-string\">\"零\"</span>, [<span class=\"hljs-string\">\"壱\"</span>], [[<span class=\"hljs-string\">\"弐\"</span>], [[<span class=\"hljs-string\">\"参\"</span>]]]]</code></pre>\n<p><code>.flat()</code> と同等の効果を得る関数は，<code>.reduce()</code> と <code>.concat()</code> と再帰処理を組み合わせることで簡単に実装することができます。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> flatten = <span class=\"hljs-function\">(<span class=\"hljs-params\">array, depth = <span class=\"hljs-number\">1</span></span>) =></span>\n  array.reduce(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">acc, val</span>) =></span>\n      acc.concat(\n        depth > <span class=\"hljs-number\">1</span> &#x26;&#x26; <span class=\"hljs-built_in\">Array</span>.isArray(val) ? flatten(val, depth - <span class=\"hljs-number\">1</span>) : val\n      ),\n    []\n  );</code></pre>\n<h3><code>Array.prototype.flatMap</code></h3>\n<p><code>Array.prototype.flatMap()</code> は前述の <code>.map()</code> と <code>.flat()</code> の組み合わせです。すなわち</p>\n<pre><code class=\"hljs language-js\">array.flatMap(func);</code></pre>\n<p>と</p>\n<pre><code class=\"hljs language-js\">array.map(func).flat(<span class=\"hljs-number\">1</span>);</code></pre>\n<p>は等価です。ここで <code>func</code> は関数で，シグネチャは</p>\n<pre><code class=\"hljs language-js\">(value: T, <span class=\"hljs-attr\">index</span>: number, <span class=\"hljs-attr\">array</span>: T[]) => U | <span class=\"hljs-built_in\">Array</span>&#x3C;U></code></pre>\n<p>です。<code>func</code> が恒等関数 <code>(x) => x</code> のときは<code>.flat()</code> と相当です。すなわち，<code>array.flatMap(x => x)</code> と <code>array.flat()</code> は等価です。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-keyword\">const</span> duplicate = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> ([x, x])\n\n> duplicate(<span class=\"hljs-string\">\"👽\"</span>)\n[<span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>]\n\n> [<span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>].map(duplicate)\n[[<span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>], [<span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>], [<span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>]]\n\n> [<span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>].flatMap(duplicate)\n[<span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>, <span class=\"hljs-string\">\"👽\"</span>]</code></pre>\n<p>また，<code>.flatMap()</code> を使うと，<code>.map()</code> と <code>.filter()</code> の効果を同時に得ることができます。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-keyword\">const</span> list = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Batman\"</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Jorker\"</span>, <span class=\"hljs-attr\">isVillain</span>: <span class=\"hljs-literal\">true</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Gordon\"</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Alfred\"</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Harvey\"</span> }\n];\n\n> list.flatMap(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =></span> v.isVillain ? [] : v.name) <span class=\"hljs-comment\">// ヴィラン以外の名前一覧が欲しい</span>\n[<span class=\"hljs-string\">\"Batman\"</span>, <span class=\"hljs-string\">\"Gordon\"</span>, <span class=\"hljs-string\">\"Alfred\"</span>, <span class=\"hljs-string\">\"Harvey\"</span>]</code></pre>\n<h3><code>Object.fromEntries()</code></h3>\n<p><code>Object.fromEntries()</code> は <code>[key, value]</code> のペアの配列からオブジェクトをつくります。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-keyword\">const</span> pairs = [[<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"🍎\"</span>], [<span class=\"hljs-string\">\"Banana\"</span>, <span class=\"hljs-string\">\"🍌\"</span>], [<span class=\"hljs-string\">\"Candy\"</span>, <span class=\"hljs-string\">\"🍬\"</span>]];\n> <span class=\"hljs-built_in\">Object</span>.fromEntries(pairs)\n{ <span class=\"hljs-string\">\"Apple\"</span>: <span class=\"hljs-string\">\"🍎\"</span>, <span class=\"hljs-string\">\"Banana\"</span> :<span class=\"hljs-string\">\"🍌\"</span>, <span class=\"hljs-string\">\"Candy\"</span>: <span class=\"hljs-string\">\"🍬\"</span> }</code></pre>\n<p><code>key</code> が重複していた場合，配列の後ろ側の値になります。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-built_in\">Object</span>.fromEntries([\n  [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"🍎\"</span>],\n  [<span class=\"hljs-string\">\"Banana\"</span>, <span class=\"hljs-string\">\"🍌\"</span>],\n  [<span class=\"hljs-string\">\"Candy\"</span>, <span class=\"hljs-string\">\"🍬\"</span>],\n  [<span class=\"hljs-string\">\"Candy\"</span>, <span class=\"hljs-string\">\"🍭\"</span>],\n  [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"🍏\"</span>]\n])\n{ <span class=\"hljs-string\">\"Apple\"</span>: <span class=\"hljs-string\">\"🍏\"</span>, <span class=\"hljs-string\">\"Banana\"</span>: <span class=\"hljs-string\">\"🍌\"</span>, <span class=\"hljs-string\">\"Candy\"</span>: <span class=\"hljs-string\">\"🍭\"</span> }</code></pre>\n<h3><code>String.prototype.{trimStart,trimEnd}</code></h3>\n<p><code>.trim()</code> は両端のホワイトスペースを取り除きますが，<code>.trimStart()</code> と <code>.trimEnd()</code> はそれぞれ，始端，終端のみに作用します。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-string\">\"   (^-^)   \"</span>.trim()\n<span class=\"hljs-string\">\"(^-^)\"</span>\n\n> <span class=\"hljs-string\">\"   (^-^)   \"</span>.trimStart()\n<span class=\"hljs-string\">\"(^-^)   \"</span>\n\n> <span class=\"hljs-string\">\"   (^-^)   \"</span>.trimEnd()\n<span class=\"hljs-string\">\"   (^-^)\"</span></code></pre>\n<h3><code>Symbol.prototype.description</code></h3>\n<p><code>Symbol</code> を作成するとき，ファクトリ関数に任意の文字列を渡すことが出来ます。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-keyword\">const</span> symbol = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"これはシンボルです\"</span>)\n> <span class=\"hljs-built_in\">String</span>(symbol)\n<span class=\"hljs-string\">\"Symbol(これはシンボルです)\"</span></code></pre>\n<p>これまで，その値を取得するには上記のように文字列に変換するしかありませんでしたが， <code>description</code> という getter でアクセスできるようになりました。</p>\n<pre><code class=\"hljs language-js\">> symbol.description\n<span class=\"hljs-string\">\"これはシンボルです\"</span></code></pre>\n<h3>Optional catch binding</h3>\n<p>この提案により，以下のような書き方ができるようになりました。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">try</span> {\n  valus(); <span class=\"hljs-comment\">// バルス！</span>\n} <span class=\"hljs-keyword\">catch</span> {\n  <span class=\"hljs-comment\">// 何かするが，errorオブジェクトは使わなくていい</span>\n}</code></pre>\n<p>エラーを揉み消したいとき（推奨はしませんが）や，どんなエラーをキャッチするのか自明なときに便利になります。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> result;\n<span class=\"hljs-keyword\">try</span> {\n  result = <span class=\"hljs-built_in\">JSON</span>.parse(str);\n} <span class=\"hljs-keyword\">catch</span> {\n  result = defaultValue;\n}</code></pre>\n<h3>Stable Array.prototype.sort()</h3>\n<p><code>Array.prototype.sort()</code> の挙動が安定しました。</p>\n<pre><code class=\"hljs language-js\">> <span class=\"hljs-keyword\">const</span> prices = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">150</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Banana\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">100</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Broccoli\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">100</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Corn\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">120</span> }\n];\n> heroes.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a.price - b.price)\n\n[\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Banana\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">100</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Broccoli\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">100</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Corn\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">120</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">150</span> }\n]</code></pre>\n<p>この例では，アルファベット順にソートされた配列を価格で昇順にソートした例です。これまでは，同じ価格のアイテムがあった場合にその順番がアルファベット順になっていることが保証されていませんでした。この度，<code>.sort()</code> を実行する前の順序が保存されたままソートされるようになりました。</p>\n<h3>その他</h3>\n<p>その他，以下のような変更がありました。</p>\n<ul>\n<li>Well-formed JSON.stringify</li>\n<li>JSON superset</li>\n<li>Function.prototype.toString revision</li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=1_hHxra0Lf4\">ES2019 Features: What Even Are They? by Tara Z. Manicsic | JSConf EU 2019 - YouTube</a></li>\n</ul>\n"}},"__N_SSG":true}