{"pageProps":{"postContent":{"title":"ElixirでMIDIファイルをパースする","date":"2017-08-26T23:28:44+09:00","slug":"parsing-midi-by-elixir","tags":["Elixir"],"draft":false,"content":"<h2>動機</h2>\n<p><a href=\"https://chooblarin.github.io/post/trying-beat-detection/\">前回のエントリ</a>では，音楽に合わせて何か絵を動かそうとして beat detection を行いましたが，事前に音に関する情報を分析するアプローチにも挑戦して見たいと思っていたところ，MIDI ファイルなら Elixir の勉強に丁度良いかもと思いついてこの記事を書きました．</p>\n<h2>MIDI</h2>\n<p>MIDI は音の情報の形式の一つです．MIDI の最も一般的なファイルが SMF(Standard MIDI Format)です．以降，SMF のファイルを単に「MIDI ファイル」と表記します．</p>\n<h2>Elixir</h2>\n<p>Elixir のパターンマッチは素晴らしいです．バイナリもパターンマッチ出来ます．</p>\n<pre><code class=\"hljs language-elixir\">iex(<span class=\"hljs-number\">1</span>)> &#x3C;&#x3C;header :: <span class=\"hljs-number\">8</span>, data :: binary>> = &#x3C;&#x3C;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>>>\n&#x3C;&#x3C;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>>>\niex(<span class=\"hljs-number\">2</span>)> header\n<span class=\"hljs-number\">1</span>\niex(<span class=\"hljs-number\">3</span>)> data\n&#x3C;&#x3C;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>>></code></pre>\n<h2>やってみる</h2>\n<p><a href=\"https://maruyama.breadfish.jp/tech/smf\">こちらを</a>参考に MIDI ファイルの中身を覗いてみる．</p>\n<p>まず，MIDI ファイルを読み込みます．</p>\n<pre><code class=\"hljs language-elixir\">iex(<span class=\"hljs-number\">1</span>) {<span class=\"hljs-symbol\">:ok</span>, data} = File.read <span class=\"hljs-string\">'sample.midi'</span>\n{<span class=\"hljs-symbol\">:ok</span>,\n &#x3C;&#x3C;<span class=\"hljs-number\">77</span>, <span class=\"hljs-number\">84</span>, <span class=\"hljs-number\">104</span>, <span class=\"hljs-number\">100</span>, 0, 0, 0, <span class=\"hljs-number\">6</span>, 0, <span class=\"hljs-number\">1</span>, 0, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">224</span>, <span class=\"hljs-number\">77</span>, <span class=\"hljs-number\">84</span>, <span class=\"hljs-number\">114</span>, <span class=\"hljs-number\">107</span>, 0, 0, 0,\n   <span class=\"hljs-number\">36</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">82</span>, <span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">105</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">81</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">161</span>, <span class=\"hljs-number\">32</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">88</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>,\n   <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">24</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">143</span>, <span class=\"hljs-number\">143</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">88</span>, ...>>}</code></pre>\n<p>バイナリさんこんにちわ．MIDI ファイルは必ずヘッダチャンクとトラックチャンクで構成されています．</p>\n<h3>ヘッダ</h3>\n<p>ヘッダを覗いてみます．ヘッダのチャンク構成は以下のようになっています．括弧の数字はバイト数です．</p>\n<p><em>&#x3C;\"MThd\"> &#x3C;データ長 (4)> &#x3C;フォーマット (2)> &#x3C;トラック数 (2)> &#x3C;時間単位 (2)></em></p>\n<p>パターンマッチを使うと一発でヘッダをパース出来ます．</p>\n<pre><code class=\"hljs language-elixir\">iex(<span class=\"hljs-number\">2</span>)> &#x3C;&#x3C;<span class=\"hljs-string\">\"MThd\"</span>, <span class=\"hljs-number\">6</span> :: size(<span class=\"hljs-number\">32</span>), format :: size(<span class=\"hljs-number\">16</span>), num_of_tracks :: size(<span class=\"hljs-number\">16</span>), time_unit :: size(<span class=\"hljs-number\">16</span>), rest :: binary>> = data\n&#x3C;&#x3C;<span class=\"hljs-number\">77</span>, <span class=\"hljs-number\">84</span>, <span class=\"hljs-number\">104</span>, <span class=\"hljs-number\">100</span>, 0, 0, 0, <span class=\"hljs-number\">6</span>, 0, <span class=\"hljs-number\">1</span>, 0, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">224</span>, <span class=\"hljs-number\">77</span>, <span class=\"hljs-number\">84</span>, <span class=\"hljs-number\">114</span>, <span class=\"hljs-number\">107</span>, 0, 0, 0,\n  <span class=\"hljs-number\">36</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">82</span>, <span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">105</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">81</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">161</span>, <span class=\"hljs-number\">32</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">88</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>,\n  <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">24</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">143</span>, <span class=\"hljs-number\">143</span>, 0, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">88</span>, <span class=\"hljs-number\">4</span>, ...>>\n\niex(<span class=\"hljs-number\">3</span>)> format\n<span class=\"hljs-number\">1</span>\niex(<span class=\"hljs-number\">4</span>)> num_of_tracks\n<span class=\"hljs-number\">20</span>\niex(<span class=\"hljs-number\">5</span>)> time_unit\n<span class=\"hljs-number\">480</span></code></pre>\n<p>フォーマット 1，トラック数 20，時間単位 480 のようです．MIDI ファイルのフォーマットは\"0\", \"1\", \"2\"の 3 種類が定義されています．フォーマット 1 はトラック構成を保存したフォーマットです (後にみていくと分かります)．このファイルは 20 トラックの情報を含んでいます．時間単位 480 の意味は，四分音符の分解能が 480 という意味です．よくわからなくても気にせずに進みます．</p>\n<p>ここで<code>MidiParser</code>という module を定義しておきます．</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">defmodule</span> <span class=\"hljs-title\">MidiParser</span></span> <span class=\"hljs-keyword\">do</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">parse_header</span></span>(&#x3C;&#x3C;\n  <span class=\"hljs-string\">\"MThd\"</span>,\n  <span class=\"hljs-number\">6</span> :: size(<span class=\"hljs-number\">32</span>),\n  format :: size(<span class=\"hljs-number\">16</span>),\n  num_of_tracks :: size(<span class=\"hljs-number\">16</span>),\n  time_unit :: size(<span class=\"hljs-number\">16</span>),\n  _ :: binary>>) <span class=\"hljs-keyword\">do</span>\n\n  IO.puts <span class=\"hljs-string\">\"format: <span class=\"hljs-subst\">#{format}</span>\"</span>\n  IO.puts <span class=\"hljs-string\">\"number of tracks: <span class=\"hljs-subst\">#{num_of_tracks}</span>\"</span>\n  IO.puts <span class=\"hljs-string\">\"time unit: <span class=\"hljs-subst\">#{time_unit}</span>\"</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n<h3>トラック</h3>\n<p>トラックのチャンク構成は以下のようになっています．</p>\n<p><em>&#x3C;\"MTrk\"> &#x3C;データ長 (4)> &#x3C;データ本体> &#x3C;...残りのトラックデータ></em></p>\n<p><code>MidiParser</code>に各トラックのデータ本体のバイナリを取得する関数を追加します．</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">defmodule</span> <span class=\"hljs-title\">MidiParser</span></span> <span class=\"hljs-keyword\">do</span>\n\n  ...\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">parse_track</span></span>(data) <span class=\"hljs-keyword\">do</span>\n    _parse_track_chunk(data, [])\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">defp</span> <span class=\"hljs-title\">_parse_track_chunk</span></span>(&#x3C;&#x3C;>>, acc) <span class=\"hljs-keyword\">do</span>\n    Enum.reverse(acc)\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">defp</span> <span class=\"hljs-title\">_parse_track_chunk</span></span>(&#x3C;&#x3C;\n    <span class=\"hljs-string\">\"MTrk\"</span>,\n    length :: size(<span class=\"hljs-number\">32</span>),\n    body :: binary - size(length),\n    chunks :: binary>>, tracks) <span class=\"hljs-keyword\">do</span>\n\n    _parse_track_chunk(chunks, [body | tracks])\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre>\n<p>トラック部分のバイナリを渡して…</p>\n<pre><code class=\"hljs language-elixir\">iex(<span class=\"hljs-number\">7</span>)> tracks = MidiParser.parse_track(chunks)</code></pre>\n<p><code>tracks</code>はトラックの情報を持った binary のリストです．長さを調べると…</p>\n<pre><code class=\"hljs language-elixir\">iex(<span class=\"hljs-number\">8</span>)> length tracks\n<span class=\"hljs-number\">20</span></code></pre>\n<p>20 トラック分のバイナリを取得出来ました．これからトラック情報をパースしていきます．</p>\n<p><em>&#x3C;データ本体></em> は以下のような構成です．</p>\n<p><em>&#x3C;デルタタイム> &#x3C;イベント> &#x3C;デルタタイム> &#x3C;イベント> &#x3C;デルタタイム> &#x3C;イベント>...</em></p>\n<p>デルタタイムは可変長バイト列です．先頭 1 ビットはフラグで残りの 7 ビット分が数値を表しています．MSB(Most Significant Byte)が 1 のとき，次のバイトもデルタタイムを表現していることになります．この表現方法を解釈する関数を定義してみました．</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">_extract_variable_length</span></span>(&#x3C;&#x3C;msb :: <span class=\"hljs-number\">1</span>, exp :: <span class=\"hljs-number\">7</span>, _ :: binary>>) <span class=\"hljs-keyword\">when</span> msb == 0 <span class=\"hljs-keyword\">do</span>\n  &#x3C;&#x3C;exp :: <span class=\"hljs-number\">7</span>>>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">_extract_variable_length</span></span>(&#x3C;&#x3C;_ :: <span class=\"hljs-number\">1</span>, exp :: <span class=\"hljs-number\">7</span>, rest :: binary>>) <span class=\"hljs-keyword\">do</span>\n  <span class=\"hljs-keyword\">next</span> = _extract_variable_length(rest)\n  &#x3C;&#x3C; &#x3C;&#x3C;exp :: <span class=\"hljs-number\">7</span>>> :: bitstring, <span class=\"hljs-keyword\">next</span> :: bitstring >>\n<span class=\"hljs-keyword\">end</span></code></pre>\n<p>これで数値部分の bitstring を抽出出来ました．バイト列に戻して値を抽出します．</p>\n<pre><code class=\"hljs language-elixir\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">extract_variable_length</span></span>(data) <span class=\"hljs-keyword\">do</span>\n  bits = _extract_variable_length(data)\n  bs = bit_size(bits)\n  padding_size = <span class=\"hljs-number\">8</span> - rem(bs, <span class=\"hljs-number\">8</span>)\n  byte_data = &#x3C;&#x3C; &#x3C;&#x3C;0 :: size(padding_size)>> :: bitstring, bits :: bitstring >>\n\n  bit_length = padding_size + bs\n  &#x3C;&#x3C;length :: size(bit_length)>> = byte_data\n  &#x3C;&#x3C;_ :: size(bit_length), chunks :: binary>> = data\n  {length, chunks}\n<span class=\"hljs-keyword\">end</span></code></pre>\n<p>あとはイベントを解釈するコードを追加するのですが，長くなりそうなので続きは後日．\nソースコードは<a href=\"https://github.com/chooblarin/midi_parser\">こちら</a>に置きました．</p>\n<p>(追記: 2017/09/18)</p>\n<p>MIDI シーケンスに合わせてアニメーションする作品を公開しました．</p>\n<p>https://sotahatakeyama.com/#/color-ball-dancing/</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html\">Standard MIDI-File Format Spec. 1.1, updated</a></li>\n<li><a href=\"https://maruyama.breadfish.jp/tech/smf\">SMF(Standard MIDI File)フォーマット解説 | 技術的読み物 | FISH&#x26;BREAD</a></li>\n<li><a href=\"https://zohaib.me/binary-pattern-matching-in-elixir/\">Binary pattern matching in Elixir with PNG parsing example</a></li>\n</ul>\n"}},"__N_SSG":true}