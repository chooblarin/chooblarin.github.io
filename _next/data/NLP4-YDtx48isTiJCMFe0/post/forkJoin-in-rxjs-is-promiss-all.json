{"pageProps":{"postContent":{"title":"RxJSのforkJoinはPromise.all相当","date":"2018-10-11T02:08:00+09:00","slug":"forkJoin-in-rxjs-is-promiss-all","tags":["RxJS"],"draft":false,"content":"<p>以前（ずいぶんと前だけど）に，<a href=\"https://chooblarin.github.io/post/20160529/\">RxJavaについてのエントリ</a>で，「RxJavaに <code>Promise.all()</code>が欲しい」という話をしました．この時に紹介したRxJavaの<code>concatMapEager</code>は，当時はExperimentalでしたが現在はStableになっています．</p>\n<hr>\n<p>今回はRxJavaではなくRxJSについてです．</p>\n<p>先のエントリの中で，私が求めいたのは</p>\n<ol>\n<li>処理が並行して実行される</li>\n<li>順番が保存されている</li>\n</ol>\n<p>という特徴を持ったオペレータでした．そして最近，RxJSの<code>forkJoin</code>を知りました．</p>\n<h2>RxJSのforkJoin</h2>\n<p>RxJSに<code>forkJoin</code>というAPIがあります．これはObservableのリストを受け取り，それらが最後にemitした値のリストのObservableをつくります．</p>\n<p>例えば</p>\n<pre><code class=\"hljs language-js\">forkJoin(\n  <span class=\"hljs-keyword\">of</span>(<span class=\"hljs-string\">'君がッ'</span>, <span class=\"hljs-string\">'泣くまで'</span>),\n  <span class=\"hljs-keyword\">of</span>(<span class=\"hljs-string\">'殴るのを'</span>, <span class=\"hljs-string\">'やめないッ！'</span>),\n).subscribe(<span class=\"hljs-built_in\">console</span>.log); <span class=\"hljs-comment\">// [\"泣くまで\", \"やめないッ！\"]</span></code></pre>\n<p>という具合です．<code>forkJoin(...)</code>は<code>Promise.all(...)</code>のObservable版なのです．</p>\n<p>次に，こんなモノを用意しました．</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> rand = <span class=\"hljs-function\">() =></span> <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-number\">3</span>) * <span class=\"hljs-number\">1000</span>;\n<span class=\"hljs-keyword\">const</span> delayedEcho = <span class=\"hljs-function\">(<span class=\"hljs-params\">message</span>) =></span> <span class=\"hljs-keyword\">of</span>(message).pipe(delay(rand()));</code></pre>\n<p>ランダム時間後にメッセージをそのまま返してくれる，その名も<code>delayedEcho</code>です．</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> ids = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-string\">'2'</span>, <span class=\"hljs-string\">'3'</span>, <span class=\"hljs-string\">'4'</span>, <span class=\"hljs-string\">'5'</span>];\n<span class=\"hljs-keyword\">const</span> observables = ids.map(delayedEcho);\nforkJoin(observables).subscribe(<span class=\"hljs-built_in\">console</span>.log);\n<span class=\"hljs-comment\">// [\"1\", \"2\", \"3\", \"4\", \"5\"]</span></code></pre>\n<p>はい，完全に思い通りに動いてくれました．</p>\n<h2>xxxMapなオペレータ達</h2>\n<p>ここから先はおまけです．先ほどの<code>delayedEcho</code>で遊んでみます．</p>\n<h3>mergeMap</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span>(ids)\n  .pipe(\n    mergeMap(delayedEcho),\n    toArray()\n  )\n  .subscribe(<span class=\"hljs-built_in\">console</span>.log);\n\n<span class=\"hljs-comment\">// [\"3\", \"5\", \"1\", \"2\", \"4\"]</span></code></pre>\n<p><code>mergeMap</code>は<code>flatMap</code>です (<code>flatMap</code>が<code>mergeMap</code>のエイリアス)．処理は並行に走りますが，購読される値は先着順です．</p>\n<h3>concatMap</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span>(ids)\n  .pipe(\n    concatMap(delayedEcho),\n    toArray()\n  )\n  .subscribe(<span class=\"hljs-built_in\">console</span>.log);\n\n<span class=\"hljs-comment\">// [\"1\", \"2\", \"3\", \"4\", \"5\"]</span></code></pre>\n<p><code>concatMap</code>は，処理が直列です．現在の処理が完了するまで次の処理を開始しません．したがって，上記の例は<code>mergeMap</code>の平均およそ5倍の時間が掛かります．</p>\n<h3>switchMap</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span>(ids)\n  .pipe(\n    switchMap(delayedEcho),\n    toArray()\n  )\n  .subscribe(<span class=\"hljs-built_in\">console</span>.log);\n\n<span class=\"hljs-comment\">// [\"5\"]</span></code></pre>\n<p><code>switchMap</code>は最新のObservableに関心を切り替えます．</p>\n<p>ここで，<code>delayedEcho</code>に少し小細工をします．</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> delayedEcho = <span class=\"hljs-function\">(<span class=\"hljs-params\">message</span>) =></span> <span class=\"hljs-keyword\">of</span>(message)\n  .pipe(\n    tap(<span class=\"hljs-built_in\">console</span>.log), <span class=\"hljs-comment\">// &#x3C;= これを追加</span>\n    delay(rand())\n  );</code></pre>\n<p>そして先ほどの<code>switchMap</code>のコードをもう一度実行すると...</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span>(ids)\n  .pipe(\n    switchMap(delayedEcho),\n    toArray()\n  )\n  .subscribe(<span class=\"hljs-built_in\">console</span>.log);\n\n<span class=\"hljs-comment\">// \"1\"</span>\n<span class=\"hljs-comment\">// \"2\"</span>\n<span class=\"hljs-comment\">// \"3\"</span>\n<span class=\"hljs-comment\">// \"4\"</span>\n<span class=\"hljs-comment\">// \"5\"</span>\n<span class=\"hljs-comment\">// [\"5\"]</span></code></pre>\n<p><code>\"1\"</code>から<code>\"4\"</code>は無視されたかと思いきや，全てのObservableの処理は実行を開始していたことがわかります．</p>\n<h3>exhaustMap</h3>\n<p>最後が<code>exhaustMap</code>です．このオペレータは重要です．</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span>(ids)\n  .pipe(\n    exhaustMap(delayedEcho),\n    toArray()\n  )\n  .subscribe(<span class=\"hljs-built_in\">console</span>.log);\n\n<span class=\"hljs-comment\">// \"1\"</span>\n<span class=\"hljs-comment\">// [\"1\"]</span></code></pre>\n<p><code>exhaustMap</code>は，前の処理が完了していなかい場合には後続の処理を無視します．この挙動は，非同期処理が不整合を起こさないための様々なケースに使えます．</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/api\">RxJS - API List</a></li>\n</ul>\n"}},"__N_SSG":true}