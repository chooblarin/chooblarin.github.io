{"pageProps":{"postContent":{"title":"Observableは友達","date":"2015-03-17T22:57:00+09:00","slug":"observable_is_my_friend","tags":["Java","RxJava"],"draft":false,"content":"<p>この文章は RxJava と RxAndroid について書かれています．\n開発中の Android アプリに導入してみて得られた知見をまったりざっくりまとめてみます．</p>\n<h3>Rx とリアクティブプログラミング</h3>\n<p>これについて解説している記事は既にたくさん（ここ最近では特に）あるので割愛します．\nせっかくなので分かりやすかった記事をいくつかリンクします．</p>\n<ul>\n<li><a href=\"https://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/\">Grokking RxJava</a></li>\n<li><a href=\"https://futurice.com/blog/top-7-tips-for-rxjava-on-android\">Top 7 Tips for RxJava on Android — Futurice</a></li>\n<li><a href=\"https://steps.dodgson.org/b/2014/12/07/reactive-porn/\">Reactive Porn - steps to phantasien</a></li>\n<li><a href=\"https://okapies.hateblo.jp/entry/2015/03/04/031148\">関数型プログラマのための Rx 入門（前編） - Okapies' Archive</a></li>\n</ul>\n<h3>Observable の生成</h3>\n<p><a href=\"https://github.com/ReactiveX/RxJava/wiki/Creating-Observables\">Observable の生成</a>は複数の方法があります．\n<code>create()</code>を使うとあらゆるデータを<code>Observable</code>にラップ出来ます．\nファイル読み書き，ローカル DB アクセス，ネットワーク通信に関連するデータはほとんど全て<code>create()</code>を使って Observable に出来ます．</p>\n<p>例えば，assets フォルダの中の\"hoge.json\"からテキストを読み込んでくるときはこんなカンジ．</p>\n<pre><code class=\"hljs language-java\">Observable&#x3C;JSONObject> <span class=\"hljs-title hljs-function\">load</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Context context)</span> {\n <span class=\"hljs-keyword\">return</span> Observable\n   .create((OnSubscribe&#x3C;AppItem>) subscriber -> {\n     <span class=\"hljs-type\">InputStream</span> <span class=\"hljs-variable\">inputStream</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n     <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">reader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n     <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">buf</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-class\">StringBuilder</span>();\n\n     <span class=\"hljs-keyword\">try</span> {\n       inputStream = context.getAssets().open(<span class=\"hljs-string\">\"hoge.json\"</span>);\n       reader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-class\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-class\">InputStreamReader</span>(inputStream));\n       String str;\n\n       <span class=\"hljs-keyword\">while</span> ((str = inputStream.readLine()) != <span class=\"hljs-literal\">null</span>) {\n         buf.append(str);\n       }\n       subscriber.onNext(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-class\">JSONObject</span>(buf.toString()));\n       subscriber.onComplete();\n\n     } <span class=\"hljs-keyword\">catch</span> (JSONException | IOException e) {\n       subscriber.onError(e);\n\n     } <span class=\"hljs-keyword\">finally</span> {\n       <span class=\"hljs-keyword\">try</span> {\n         <span class=\"hljs-keyword\">if</span> (inputStream != <span class=\"hljs-literal\">null</span>) {\n           inputStream.close();\n         }\n         <span class=\"hljs-keyword\">if</span> (reader != <span class=\"hljs-literal\">null</span>) {\n           reader.close();\n         }\n       } <span class=\"hljs-keyword\">catch</span> (IOException ignored) {}\n     }\n   });\n}\n</code></pre>\n<p>呼び出し側ではこんなカンジ．</p>\n<pre><code class=\"hljs language-java\">dataService.load(context)\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(\n    _jsonObject -> {\n      bindData(_jsonObject);\n    },\n    error -> {\n      <span class=\"hljs-comment\">// error handling</span>\n    }\n  );\n</code></pre>\n<p>ローカル DB へのアクセスも．</p>\n<pre><code class=\"hljs language-java\">  Observable\n    .create(subscriber -> {\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">/* データを取得して */</span>\n        onNext(data); <span class=\"hljs-comment\">/* データをemit */</span>\n\n      } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n        <span class=\"hljs-comment\">/* エラー処理があればやっておく．トランザクションのキャンセル処理など */</span>\n        subscriber.onError(e);\n      } <span class=\"hljs-keyword\">finally</span> {\n        <span class=\"hljs-comment\">/* 後始末 */</span>\n      }\n\n      subscriber.onCompleted();\n    })\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(observer);\n</code></pre>\n<h3>Hot と Cold</h3>\n<ul>\n<li>Hot ･･･ subscribe されていなくても値を emit する．</li>\n<li>Cold ･･･ <code>subscribe()</code>が呼ばれるまで値を emit しない．<code>subscribe()</code>毎に新しく値を emit する．</li>\n</ul>\n<p>subscriber が値を emit しはじめるのは，その Observable が subscribe されてからです．つまり，<code>subscribe()</code>が呼ばれるまでは何も起こりません．\n更に，Observable は subscribe が呼ばれる度に値を<code>create</code>のオペレーターが実行されます．</p>\n<p><a href=\"https://qiita.com/toRisouP/items/f6088963037bfda658d3\">この記事</a>がわかりやすいです．</p>\n<p>例えば以下のようにファイルから読み込んだデータを複数の Observer が subscribe したいとします．</p>\n<pre><code class=\"hljs language-java\">Observable&#x3C;JSONObject> jsonObject\n  = dataService\n      .load()\n      .subscribeOn(Schedulers.io())\n      .observeOn(AndroidSchedulers.mainThread());\n\njsonObject.subscribe(observer1);\n\njsonObject.subscribe(observer2); <span class=\"hljs-comment\">// 無駄にファイルを読み直している</span>\n</code></pre>\n<p>この例では，同じデータなのに 2 回もファイルを読みにいってしまいます．\nSubject を使うと Hot な Observable でこの問題を解決出来ます．先ほどの例をこんなカンジに変えてみます．</p>\n<pre><code class=\"hljs language-java\">PublishSubject&#x3C;JsonObject> subject = PublishSubject.create();\n\nsubject.asObservable().subscribe(observer1);\nsubject.asObservable().subscribe(observer2);\n\nObservable&#x3C;JSONObject> jsonObject\n  = dataService\n      .load()\n      .subscribeOn(Schedulers.io())\n      .observeOn(AndroidSchedulers.mainThread())\n      .subscribe(subject);\n</code></pre>\n<p>以上でした．</p>"}},"__N_SSG":true}